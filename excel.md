[TOC]

# excel技巧

## 1、姓名对齐

输入姓名时，不但有三个字的姓名还有两个字的姓名。

![img](.\excel.assets\130700858_2_20180420065800363)

## 2、输入带方框的√和×

利用数据有效性，除了能够制作下拉菜单，还可以快速输入带方框的√和×。

首先设置字体为<strong> Wingdings 2</strong>

<p>注意R和S之间是英文的逗号。</p>

<p>然后就可以点击下拉按钮，输入带方框的√和×了。</p>

![img](.\excel.assets\130700858_3_20180420065800582)

## 3、按职位排序

在Excel中，通常可以将数据按升序、降序进行排序处理。

如下图所示，如果要对AB列的数据按单位内部职务排序，该如何处理呢？

![img](.\excel.assets\130700858_4_20180420065800847)

首先选中D2:D7单元格的内部职务对照表，然后点击【文件】→【选项】→【高级】→编辑自定义列表。

![img](.\excel.assets\130700858_5_20180420065800957)

接下来就可以使用自定义序列进行排序了。

先单击要职务所在列的任意单元格，然后单击→【排序】，再按下图步骤操作即可：

![img](.\excel.assets\130700858_6_20180420065801394)

## 4、快速输入性别

输入1就是男，输入0就是女，1和0总有说不完的故事

![img](.\excel.assets\130700858_7_20180420065801644)

自定义格式代码为：[=1]男;[=0]女

## 5、填充合并单元格

咱们说过，在工作表中尽量不使用合并单元格，否则就是给自己挖坑。那么对已有合并单元格的工作表，如何快速整理呢？

其实很简单：只要选中数据区域，先取消合并单元格。

然后按Ctrl+G，定位空值。

再输入等号，按方向键的上箭头，最后按Ctrl+回车即可。

![img](.\excel.assets\130700858_12_20180420065802394)

## 6、不规则合并单元格编号（三种方式）

对于数据的快速填充，在之前的文章中也介绍了几种常见的方法，但在日常的工作中，有时也会遇到常规方法不太灵的情况，就像下面图中的这种，需要在不规则的合并单元格中按顺序输入序号。

![img](.\excel.assets\00e93901213fb80eb30b391e6bc4c32bb8389438.jpeg)

如果按照常规方法向下拖动的话，会发现结果提示错误。要是一个一个输入的话，数据量大还麻烦。

![img](.\excel.assets\06180612ceb191f60c11689cdf40125d2686.gif)

毕竟办法总比困难多，下面介绍三种解决这种问题的方法。

（1）COUNT函数

COUNT函数在Excel中用来对某个集合或者是某个区域内进行计数，COUNT函数的语法是：COUNT(**value1,value2,**……)

COUNT函数括号内至少得有一个值，即value1是必需参数，其后面的value2,value3等是可选参数。

特别需要注意的有几点：

1、如果参数为数字、日期或者代表数字的文本，出现一次记一次数；

2、错误值、空值、逻辑值、文字则将被记为0.

现在进行分析，因为COUNT函数是计数的，我们就利用需要填充单元格上方有几个单元格来计数。表中第一个需要填充的单元格是A3，它的上方是单元格A2，它的上方有0个填充序号的单元格；第三个需要填充的是A8,它上方有2个填序号的单元格。也就是说需要填充的数字是它上方填充序号单元格个数+1。用公式来写，A3单元格中的公式是COUNT（A2：A2）+1（对文字的统计记为0），A8单元格中的公式是COUNT（A2：A7）+1。公式说明，统计区域的开始位置都是A2，因此要用绝对引用$A$2，故应输入的公式是

COUNT（$A$2:A2）+1；

结束位置都是需要填充单元格的上一个单元格，因此，这种规律的填充都是用CTRL+ENTER来确定。

![img](https://pic.rmb.bdstatic.com/51449850fc8f47ced94c33a36a6742ab9331.gif)

（2）COUNTA函数

COUNTA函数返回的是统计区域中非空单元格的个数，通俗地说就是，只要单元格中有内容，计数就加1,。COUNTA函数的语法是：

COUNTA(**value1, value2**， ……)

它跟COUNT函数一样，value1是必需参数，其后面的value2,value3等是可选参数。

COUNTA函数的填充不规则合并单元格的原理和COUNT函数类似，区别就是COUNTA函数不管单元格里内容是什么，只要非空，就计数。对于A3单元格，COUNTA（A2：A2）返回1；对于A8单元格，COUNTA（A2：A7）返回3，正好是需要填充的数。因此在A3单元格中填充的公式就是

COUNTA（$A$2:A2）

同样也是按CTRL+ENTER来确定。

![img](https://pic.rmb.bdstatic.com/3af51cb06cf88faa180a22bc106c64687530.gif)

（3）MAX函数

MAX函数比较简单，它的意思是找到一组数的最大值。MAX函数的语法是：

MAX(**number1,number2,**……)

注意：如果是数字以外的值，则返回0。

根据MAX函数的特点，我们分析，对于第一个需要填充数据的A3单元格，MAX（A2：A2）返回值是0，而我们应该填充的是1，需要加1；对于第三个需要填充的A8单元格，MAX（A2:A7）返回值是2，应该加1. 因此A3单元格需要填充的公式是

MAX（$A$2：A2）+1

然后同样按CTRL+ENTER来确定。

![img](https://pic.rmb.bdstatic.com/d5a839dc8747cac8b98f784a2d3301608266.gif)

## 7、获取合并单元格的值

**第一，合并单元格计算问题**

三个小组，每个小组每个人分配的金额不一样，要将金额按照每个人的提成比例核算出每个人的提成。 

![img](.\excel.assets\20170729194938.gif)

 

学员说如果EXCEL数据换成下面这样，他会做！

是的哦！如果一开始设计数据源的时候，就这样规范，那提成就不是难事儿了，谁都会做。=C2*D2，下拉就搞定了！ 

![img](.\excel.assets\20170729194954.gif)

 

可是，身为职场人，有时候我们也很无奈，没有驾驭数据源的权利，比如说，领导设计的表格，我们只有接受的份儿。那这种情况，我们只有靠自己了，多会些Excel技能。

 

针对上面的问题，给大家分享两个相关技巧。

1.取消合并单元格并填充相同内容

选取取消含合并的单元格区域，单击取消“合并后居中”命令。编辑-定位-定位条件-空值。把光标放在编辑栏中，输入=选取区域中反白显示单元格上面的单元格地址。按ctrl+endter结束填充。

不会的伙伴可以参考下面的小动画演示：

![img](.\excel.assets\20170729195015.gif)

 

就想装酷，不想用技巧，非得要用公式？那满足你！

如果合并单元格是文字，可以使用公式：=LOOKUP("座座座座座",A$1:A1)

用"座"是因为LOOKUP函数会从参数2的区域中选择“最后一个”小于等于参数1的值，而"座"这个字的代码是55289，一般来说不会有大于它的字。如果A列出现"座座座"或者"作作作"之类的时候，就会出错。可增加“座”字的个数来解决。 

![img](.\excel.assets\20170729195125.gif)

如果合并单元格是数字，可以使用公式：=LOOKUP(9^9,A$1:A1)，或者=LOOKUP(9E+307,A$1:A1)。

9E+307是接近Excel中能处理的最大数，可以认为是Excel中最大正数，使用该值可以有效的避免与要匹配的数据值相同。Lookup函数在搜索不到搜索值时，会搜索区域中最后一个小于搜索值的数据。 

![img](.\excel.assets\20170729195138.gif)

 

2.合并单元格提成计算

在E2单元格输入公式：=LOOKUP(9^9,C$2:C2)*D2，下拉。 

![img](.\excel.assets\20170729195151.gif)

 

**第二，合并单元格提取数据问题**

另外一个学员提出的问题，把A列的合并单元格数据，使用公式提取出来放在E列。 

![img](.\excel.assets\20170729195221.png)

 

你能帮助写一个公式吗？给一个参考公式作为思路提示：=INDIRECT("A"&(4*ROW())-3)，

## 8、文字合并专题

合并和提取是文本处理中最最常见的任务。



例如，将下表中各个单元格的文字合成1个新的句子：



![img](.\excel.assets\79943622_2)



而利用不同的函数公式，操作方法和结果都有所不同。





**&连字符**&能够直接将一个一个的文本连接起来，形成一个新的文本：



> 公式：=A1**&**B1**&**C1
>
> 结果：爱老虎油





然而，&连字符先天残疾，有很多个字符时，也不能直接引用整片区域进行合并，依然只能一个个手工添加。操作过程如下：

![img](.\excel.assets\79943622_3)





**Phonetic 函数**用Phonetic就省事很多，它可以引用一个区域（只能一个），将区域内所有单元格的文本型数据拼合在一起。
例如将下表中的全部文本拼合起来：



![img](.\excel.assets\79943622_2)



可以使用如下公式





> 公式：=**phonetic**(A1:D1)

> 结果：爱老虎油





但是明明D1里有一个数字1314，为什么没出现在结果里呢？



因为，phonetic只是个兼职合并函数而已。它本职工作是提取日文拼音，是日文版来客串一下的，人家只是恰好可以合并文字而已。
这个客串函数个性非常独特，因为它眼里只有文本型数据，对公式结果、数值、日期时间等等通通视而不见。所以1314就是被狗吃掉了……



此公式的输入就比&连字符简单多了：



![img](.\excel.assets\79943622_4)





**Concat 函数**

而Concat就比&和phonetic更加完美，因为它既能引用一个区域直接合并，又不会漏掉数值、日期和公式结果，还能引用多个区域，简直不能更完美了。



![img](.\excel.assets\79943622_2)





> 公式：=**concat**(A1:D1)
>
> 结果：爱老虎油1314





不过，很遗憾，完美版本的Concat只有2016版才有。

在之前的版本中，它有个前身，叫 Concatenate。Concatenate和&公式一个德性，只能逐个添加。名称又太长，还不如用&来得方便。估计是Office工程师自己都忍不了了，才在2016版添加了一个加强版吧。
这个加强版可棒了：

![img](.\excel.assets\79943622_5)



以上三种合并函数，分别合成的结果放在一起，结果就是酱紫的：

 

![img](.\excel.assets\79943622_6)



一个宅男表哥用公式向喜欢的妹子发出三行爱的告白。

结果，这个妹子是个表妹，迅速用下面这个函数做出了回应……





**Textjoin 函数**

用分隔符将多个字符串联起来。

![img](.\excel.assets\79943622_7)





> 公式：**textjoin**(“！”,True,A1:D1)**&”！”**
>
> 结果：你！是！个！好人**！**


于是，此公式的含义为，将A1：D1中每个单元格的内容用叹号串联起来，如果有空格则忽略，最后缺少的叹号用&单独补一个。



因为有函数辅助输入工具条，写这个公式也不难：

![img](.\excel.assets\79943622_8)





有一个神奇的函数，可以按照指定的次数，将自己反复拼合起来，俗称自撸。啊，不，是重复。





**Rept 函数**

它的语法是Rept(**字符串**,**重复次数**)。好想让妹子用Rept再来一次暴击：



![img](.\excel.assets\79943622_9)





> 公式：**rept**(A1,**3**)
>
> 结果：你是个好人！你是个好人！你是个好人！


公式含义再明显不过了。



![img](.\excel.assets\79943622_10)

好喜欢Rept函数输入后按下Enter键的感觉：



![img](.\excel.assets\79943622_11)



![img](.\excel.assets\79943622_10)









![img](.\excel.assets\79943622_12)

**文字提取**


提取型文本函数，就是从1个文本中挑出一部分。常用的提取函数就有Left、Right、Mid（middle的简写）三种。



**Left 函数**

从左边开始算起，提取若干字符。例如从下面诗句提取左边的7个字符：

![img](.\excel.assets\79943622_13)



> 公式：=**Left**(A1,**7**)
>
> 结果：一江春水向东流





**Right 函数**而提取右边的7个字符，就要用函数Right：

![img](.\excel.assets\79943622_14)





> 公式：=**Right**(A1,**7**)
>
> 结果：我也没有女盆友



Left 和 Right 函数语法结构相同：**函数名(字符串,提取数量)。**只是一左一右，提取的方向不一样。



但是第三个函数Mid就厉害得多，它能够从中间指定的位置开始提取。


**Mid 函数**基本语法是 **Mid(字符串,起始位置,提取数量)**



例如，从下面诗句中提取清泪两字，就可以从第11个字符开始提取2个字符（逗号也算一个）。



![img](.\excel.assets\79943622_15)





> 公式：=**Mid**(A3,**11**,**2**)&**Right**(A3,**1**)
>
> 结果：清泪流


注意到了嘛，上面的公式还用到了连字符&，将两个公式计算的结果拼在一起，得到了最终结果。







![img](.\excel.assets\79943622_16)
**字符清洗**



从网页上或神队友那弄来的数据，可能会有莫名其妙的空格和换行符。这些字符虽然看不见，但却会导致公式计算结果出错。所以通常会用Clean或Trim两个函数进行清洗。



他们语法也一样，都是 **函数名(字符串)**。但功能上却有细微的差别：

**
**

**
**

**Clean 函数**

字面意思是清洁，它只清除换行符等看不见的非打印字符，却无法去除空格。

**
**

**
**

**Trim 函数**

字面意思是修剪，它会裁头去尾，将前后的空格以及文本内部多余的空格全部清除，但是按英文使用习惯，英文中间会自动保留一个空格字符作间隔。



例如，A1单元格中的字符串有很多多余的空格及2个换行符。

![img](.\excel.assets\79943622_17)



分别用Clean和Trim函数处理的结果如下：

![img](.\excel.assets\79943622_18)





![img](.\excel.assets\79943622_19)
**文字替换**

Replace和Substitue这哥俩的能力是”置换“。功能类似，但是定位的方法不同。

**
****
****Substitute 函数**

Substitute是以字符定位字符。

![img](.\excel.assets\79943622_20)

例如，找出诗句中的“船”字，然后替换成“床”，公式和结果如下：





> 公式：=**Substitute**(A1,”**船**”,”**床**”)
>
> 结果：百年修得同**床**度，霉霉三月又分手





**Replace 函数**

而Replace则是以位置定位字符。

![img](.\excel.assets\79943622_21)

例如，从第13个字符开始提取1个字符“汉“，然后把”汉“替换成新的字符“妹“，公式和结果如下：





> 公式：=**Replace**(A1,**13**,**1**,”**妹**”)
>
> 结果：此情可待成追忆，我要做撩妹高手




感觉自己是在冒着跪榴莲的风险在写这篇推送……



替换函数还有一项独门秘技：把替换为的字符写成空值(“”)，替换就变成了删除。看哪个字符不顺眼，一言不合就可以让它消失。





![img](.\excel.assets\79943622_22)
**精确查找**


Find和Search，都能掘地三尺，精准定位某个字符在文本中的具体位置。



**Find 函数**

![img](.\excel.assets\79943622_23)



公式：=**Find**('**King**',A1)

结果：2



计算结果说明King在整句中是从第2个字符开始出现的。





**Search 函数**

![img](.\excel.assets\79943622_24)





> 公式：=**Search**('**洪荒**',A1)
>
> 结果：6



结果表明，“洪荒”在整句中是从第6个字符开始的。



虽然 Find 和 Search 都是返回某个字符在字符串中的位置信息，结果都是一个数值。但还是有细微差别，Search 可以用通配符模糊查找。例如，“K?ng”就能把 King、Kong、Kang 都找出来，而Find却做不到。



但是，计算返回结果是一个位置数值，有用吗？

接着往下看，你就知道可以怎么用！





![img](.\excel.assets\79943622_25)



![img](.\excel.assets\79943622_26)她是怎么知道的？



![img](.\excel.assets\79943622_27)
**长度计算**

Excel中有两把度量文本长度的尺子：Len 函数 和 LenB 函数





**Len 函数**

不管中文还是英文、数字，Len都将每个字符算作1。 

![img](.\excel.assets\79943622_28)



> 公式：=**Len**(A1)
>
> 结果：15





两句七律加一个符号，总共15个字符。





**LenB 函数**

LenB后面多出来的那个B是Byte(字节) 的意思，是按字节来算。1个汉字及中文标点都是双字节，长度都是2。但英文字母和数字通常都是1个字节，长度只有1。


于是，同样是14个汉字和一个标点的诗句，用LenB的计算结果不一样。

![img](.\excel.assets\79943622_29)





> 公式：=**LenB**(A1)
>
> 结果：30







LenB 和 Len之间的差异，

常常用来处理中英文混合的情况，比如



> 公式：=**LenB**(“King是好人”)-**Len**(“King是好人”)
>
> 结果：3



由于汉字LenB计算出来的长度是Len的两倍，但英文字母长度相等，两个公式之差，就是汉字的个数。
以上结果正说明字符串中有3个汉字。如果再配合Right函数，就可以把中文单独提取出来。





**Text 格式转换函数**

text函数能够让单元格数值按照指定的格式显示出来，例如固定显示成4位数，不足就补0的处理方法如下：

![img](.\excel.assets\79943622_30)





> 公式：=**TEXT**(A1,'**0000**')
>
> 结果：0069









------







以上就是常用的文本函数用法，然而很多人可能会有这样的疑问。

“合并和提取用在哪很好理解，可是查找一个字符并返回位置信息，到底有什么用？”



有些函数计算结果自身并没有多大意义，却能够辅助完成其他任务。比如Len先求出长度后，就可以按照长度来排个名次……



更厉害的是，计算结果还可以作为其他函数的参数啊。比如要把下图中每一个数字提取出来变成 QiuYeXXXX的格式，只用一个函数，是办不到的。

![img](.\excel.assets\79943622_31)



但是多个函数组合起来使用，上万行的数据也能双击搞定，只需要花几秒钟时间写一个公式就够了：

![img](.\excel.assets\79943622_32)



图中演示的公式就综合运用了4种文本函数，逐步求值的结果如下图：
![img](.\excel.assets\79943622_33)


文本函数远不止这些，但常用的就是下面这16个啦！其他函数，需要用时再找吧~

![img](.\excel.assets\79943622_34)
我真的不会去背这些函数，但是会根据他们能解决的问题进行观察和梳理，留意他们的特点。然后在看到其他案例时，自己再去了解一番同时加深理解。



函数看起来枯燥乏味，但只要摸清脉络，就会变得很好玩。



想当初爱上Excel，也就是纯粹觉得好玩。而文本函数中最喜欢的，就是Rept了。



因为

它可以完美表达心情：



> Rept(“你是个好人！”,6)
>
> Rept('??',9)





## 9、Excel文本函数专题

在日常的职场办公中，各种字符数据的截取、转换、统计、处理问题会频繁出现，如果你掌握一些常用的Excel文本函数，会助力你提升工作效率，事半功倍。

本文介绍10个职场最常用的Excel文本函数，包括语法结构、示例演示以及公式写法。

1、LEFT函数

2、RIGHT函数

3、MID函数

4、LEN函数

5、LENB函数

6、EXACT函数

7、TRIM函数

8、REPT函数

9、FIND函数

10、SUBSTITUTE函数

这些excel的功能可以满足绝大多数职场办公需求，下文具体介绍一下。

**职场常用Excel文本函数1：**

字符截取函数：LEFT函数

功能：从字符串左侧截取指定长度的字符。

语法结构：=LEFT(text,num_chars)

解释：=LEFT(包含要提取字符的数据,提取的字符长度)

示例公式如下。

- 

```
=LEFT(A2,2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_13_20201227084509979_wm)

***\*职场常用Excel文本函数2：\****

字符截取函数：RIGHT函数

功能：从字符串右侧截取指定长度的字符。

语法结构：=RIGHT(text,num_chars)

解释：=LEFT(包含要提取字符的数据,提取的字符长度)

示例公式如下。

- 

```
=RIGHT(A2,2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_14_2020122708451041_wm)

**职场常用Excel文本函数3：**

字符截取函数：MID函数

功能：从字符串指定位置开始截取指定长度的字符。

语法结构：

MID(text,start_num,num_chars)

解释：=MID(文本字符串,开始截取的位置，截取的长度)

示例公式如下。

- 

```
=MID(A2,2,3)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_15_20201227084510182_wm)

**职场常用Excel文本函数4：**

字符长度统计函数：LEN函数

功能：返回文本字符串的字符数。统计数据的长度，数字、英文和汉字都按1计算。

语法结构：= LEN(text)

解释：= LEN(数据)

示例公式如下。

- 

```
=LEN(A2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_16_20201227084510322_wm)

从上图可见结果，使用LEN函数统计字符长度，无论中文、英文还是数字，都按1位计算长度。

***\**\*职场常用Excel文本函数5：\*\**\***

字符长度统计函数：LENB函数

功能：返回文本字符串的字节数。统计数据的长度，数字、英文按1计算，汉字按3计算。

语法结构：= LENB(text)

解释：= LENB(数据)

示例公式如下。

- 

```
=LENB(A2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_17_20201227084510385_wm)

从上图可见结果，使用LENB函数统计字符长度，对汉字数据按2位计算长度，对英文或者数字数据，每位数据都按1位计算长度。

**职场常用Excel文本函数6：**

字符比对函数：EXACT函数

功能：字符串的精准比较，如果完全相同则返回TRUE，否则返回FALSE。

语法结构：=EXACT(text1,text2)

解释：=EXACT(文本字符串1,文本字符串2)

示例公式如下。

- 

```
=EXACT(A2,B2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_18_20201227084510627_wm)

由于EXACT函数是精准比对数据，所以对于英文大小写也能精准比对。

***\**\*职场常用Excel文本函数7：\*\**\***

字符转换函数：TRIM函数

功能：清除文本字符串中的多余空格，即前后的空格全部清除，字符中间的空格仅保留1个。

语法结构：=TRIM(text)

解释：=TRIM(文本字符串)

示例公式如下。

- 

```
=TRIM(A2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_19_20201227084510697_wm)

从上图可以发现，TRIM函数的清除空格方式，注意字符串中间的多个空格是仅保留1个。

**职场常用Excel文本函数8：**

字符重复显示函数：REPT函数

功能：按照给定的次数重复显示文本

语法结构：=REPT(text,number_times)

解释：=REPT(数据,重复显示次数)

示例公式如下。

- 

```
=REPT(A2,2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_20_20201227084510760_wm)

**职场常用Excel文本函数9：**

字符查找函数：FIND函数

功能：在文本字符串中查找指定字符的位置，返回代表位置数的数字。

语法结构：= FIND(find_text,within_text,start_num)

解释：= FIND(查找的指定字符,字符串 ,起始数)

示例公式如下。

```
=FIND("L",A2)
```

公式示意图如下所示：

![img](.\excel.assets\211315901_21_20201227084510838_wm)

在数据中查找大写字母"L"所在的位置。

**职场常用Excel文本函数10：**

字符替换函数：SUBSTITUTE函数

功能：从字符串左侧截取指定长度的字符。

语法结构：=SUBSTITUTE(text, old_text, new_text, instance_num)

解释：

=SUBSTITUTE(文本字符串, 旧文本, 新文本,从第几次出现开始替换)

示例公式如下。

```
=SUBSTITUTE(A2,"开发部","研发部")
```

公式示意图如下所示：

![img](.\excel.assets\211315901_22_20201227084510979_wm)

## 10、文本拆分

先来看数据源：

![img](.\excel.assets\196269852_2_20200718100927974)

图片中的A列是从系统导出的信息，其中包含项目名、分期、标段以及房间号，每一项之间都有一个“-”隔开。

接下来，咱们用不同的方法将这些内容分别拆分到右侧各列内，看看这些方法你都会了吗。

**方法一 分列**：

![img](.\excel.assets\196269852_3_2020071810092821)

分列的优点是各版本均可使用，操作简单效率高。

缺点是数据源变化后，结果不能自动更新，需要重新分列处理。



**方法二 快速填充**：

![img](.\excel.assets\196269852_4_20200718100928130)

快速填充适合处理规律性比较高的数据，优点是操作便捷，缺点是数据源变化后，结果同样不能自动更新，需要重新处理。而且在2013以前版本中不可用。



**方法三 Power Query**：

![img](.\excel.assets\196269852_5_20200718100928302)

此方法操作简单，而且在数据源发生变化或是增加数据后，只要右键刷新一下就好，不需要重复操作。

使用Excel 2010或是2013的小伙伴，可以通过安装Power Query插件实现，2016及以上版本的就是内置功能了。



**方法四 函数公式**：

B2单元格输入以下公式，向下向右拖动。

=TRIM(MID(SUBSTITUTE($A2,'-',REPT('  ',99)),COLUMN(A1)*99-98,99))

![img](.\excel.assets\196269852_6_20200718100928443)

使用函数公式，能够在数据源变化后自动更新结果。缺点是编辑比较复杂，而且在数据量大的情况下，计算效率比较低。

下面咱们简单说说这个公式的意思：

1、REPT函数的作用是按照给定的次数重复显示文本，REPT(' ',99)部分也就是将' '（空格）重复99次。

2、SUBSTITUTE函数的作用是在文本字符串中用新字符串替代旧字符串。

SUBSTITUTE($A2,'-', REPT(' ',99))的意思是将$A2单元格中的字符'-'，都替换成99个空格，这样做的目的就是相当于将各段字符之间的距离给拉宽了。

3、COLUMN(A1)*99-98部分，由于COLUMN函数的参数A1使用了相对引用。在公式向右复制时，公式会变成：

COLUMN(B1)*99-98

COLUMN(C1)*99-98….

得到的结果是1,100,199…..这样的一个递增序列，作为MID函数的参数。

4、MID 函数用于返回文本字符串中从指定位置开始的特定数目的字符。

MID(SUBSTITUTE($A2,'-',REPT(' ',99)),COLUMN(A1)*99-98,99)

也就是对SUBSTITUTE($A2,'-', REPT(' ',99))返回的结果分别从第1位、第100位、第199位开始截取，截取的长度为99个字符长度。

5、最后用TRIM函数清除文本中多余的空格，得到相应的科目内容。

## 11、CHAR、REPT、COLUMN、MID、TRIM、SUBSTITUTE组合

98%的人都不会使用的函数公式

EXCEL中的各种公式单个使用时都不复杂，但如何将公式灵活运用才是最终目的，如何将多个函数进行组合使用，这是很多人都不擅长的地方。本文通过一个实际展示一下EXCEL多函数组合使用的技巧，希望能给大家带来一些借鉴。

如下图所示，资料收集时，B列中的单元格包括了多种信息，现在希望将B列中的信息拆开，用右边的形式来表示。

![只有1%的人真正掌握了这个excel](.\excel.assets\124220894_1_20180208115919108)

解决方法：

选中D2：G5单元格，输入以下公式后按'CTRL + ENTER'组合键：

= SUBSTITUTE(TRIM(MID(SUBSTITUTE($B2,CHAR(10),REPT(' ',99)),1+(COLUMN(A:A)-1)*99,99)),D$1&'：',)

处理过程如下所示：

![只有1%的人真正掌握了这个excel](.\excel.assets\124220894_2_20180208115919374)

这个组合公式有点复杂，我们可以采用剥洋葱的方法一点点地分析它的处理过程。

对字符串进行处理时，一般都是处理单行字符串，所以要想办法将单元格的字符先处理成单行，再想办法进行各种替换处理。这里使用了CHAR、REPT、COLUMN、MID、TRIM、SUBSTITUTE等组合函数。

我们先从REPT和CHAR进行分析：

CHAR(10)代表回车键；

REPT(' ',99)的返回值是99个' '；

然后用SUBSTITUTE进行初步的替换处理：= SUBSTITUTE($B2,CHAR(10),REPT(' ',99))，这个函数表示将单元格B2中的回车键用多个''来替换，将B2处理成一个单行字符串，返回值为：

'项目名称： 新建驴肉工厂 项目经理：鲁达 投资额：500万 地址：太平洋'。

(COLUMN(A:A)用来取得列数的值

1+(COLUMN(A:A)-1)*99返回值为1

MID(SUBSTITUTE($B2,CHAR(10),REPT(' ',99)),1+(COLUMN(A:A)-1)*99,99)表示从上面处理过的字符串的第1个字符开始返回99个字符，返回值为'项目名称： 新建驴肉工厂 '。

再用TRIM处理字符串的空格：

= TRIM(MID(SUBSTITUTE($B2,CHAR(10),REPT(' ',99)),1+(COLUMN(A:A)-1)*99,99))

表示删除上面字符串的空格，返回值为'项目名称： 新建驴肉工厂'

最后再用一次SUBSTITUTE：

SUBSTITUTE(TRIM(MID(SUBSTITUTE($B2,CHAR(10),REPT(' ',99)),1+(COLUMN(A:A)-1)*99,99)),D$1&'：',)

表示将D1中的'项目名称：'用空值代替。

其他单元格中的公式分析过程同上。

# excel

https://blog.csdn.net/myroncham/article/details/108668481

## 查找类函数

### ROW 

- 用途： 返回给定引用的行号。

- 语法： ROW(reference) 。 Reference 为需要得到其行号的单元格或单元格区域。

- 实例： 公式“ =ROW(A6)”返回 6，如果在 C5单元格中输入公式“ =ROW()”，其计算结 果为 5。

### COLUMN 

- 用途： 返回给定引用的列标。

- 语法： COLUMN(reference) 。 

- 参数： Reference 为需要得到其列标的单元格或单元格区域。如果省略 reference ，则 假定函数 COLUMN是对所在单元格的引用。如果 reference 为一个单元格 区域，并且函数 COLUMN作为水平数组输入，则 COLUMN函数将 reference 中的列标以水平数组的形式返回。

- 实例： 公式“ =COLUMN(A3)”返回 1，=COLUMN(B3:C5)返回 2。

### CELL

- 用途： 返回某一引用区域的左上角单元格的格式、位置或内容等信息 

### IS 类函数 

- 用途：用来检验数值或引用类型的函数。 它们可以检验数值的类型并根据参数的值返回 TRUE或 FALSE。
  - ISBLANK(value) 
  - ISNUMBER(value)
  - ISTEXT(value) 
  - ISEVEN(number)
  -  ISODD(number)

### ADDRESS 

- 用途： 以文字形式返回对工作簿中某一单元格的引用。
-  语法： ADDRESS(row_num ，column_num，abs_num，a1，sheet_text) 
- 参数： 
  - Row_num是单元格引用中使用的行号 ;
  - Column_num 是单元格引用中使用的列 标;
  - Abs_num 指明返回的引用类型 (1 或省略为绝对引用， 2 绝对行号、 相对列标， 3 相对行号、 绝对列标， 4 是相对引用 );
  - A1 是一个逻辑值， 它用来指明是以 A1 或 R1C1返回引用样式。 如 果 A1为 TRUE或省略，函数 ADDRESS返回 A1 样式的引用 ; 如果 A1为 FALSE，函数 ADDRESS 返回 R1C1样式的引用。
  -  Sheet_text 为一文本，指明作为外部引用的工作表的名称，如果省 略 sheet_text ，则不使用任何工作表的名称。 
- 实例： 公式“ =ADDRESS(1 ，4，4，1)”返回 D1。

### CHOOSE

- 用途： 可以根据给定的索引值，从多达 29 个待选参数中选出相应的值或操作。 
- 语法： CHOOSE(index_num ，value1 ，value2 ，...) 。
- 参数： Index_num 是用来指明待选参数序号的值，它必须是 1 到 29 之间的数字、或者 是包含数字 1 到 29 的公式或单元格引用 ;value1 ，value2 ，... 为 1 到 29 个数值参数， 可以 是数字、单元格，已定义的名称、公式、函数或文本。
-  实例：公式“=CHOOSE(2 ，" 电脑"，" 爱好者 ") 返回“爱好者” 。公式“=SUM(A1:CHOOSE(3 ， A10，A20，A30)) ”与公式“=SUM(A1:A30)”等价(因为 CHOOSE(3 ，A10，A20，A30)返回 A30)。

### HLOOKUP 

- 用途：在表格或数值数组的首行查找指定的数值， 并由此返回表格或数组当前列中指定 行处的数值。 
- 语法： HLOOKUP(lookup_value，table_array ，row_index_num ，range_lookup) 
- 参数： Lookup_value 是需要在数据表第一行中查找的数值，它可以是数值、引用或文 字串 ;Table_array 是需要在其中查找数据的数据表，可以使用对区域或区域名称的引用， Table_array 的第一行的数值可以是文本、数字或逻辑值。 Row_index_num为 table_array 中待返回的匹配值的行序号。 Range_lookup 为一逻辑值，指明函数 HLOOKUP查找时是精确 匹配，还是近似匹配。 
- 实例： 如果 A1:B3 区域存放的数据为 34、23、68、69、92、36，则公式“ =HLOOKUP(34 ， A1:B3，1，FALSE)返回 34;=HLOOKUP(3，{1 ，2，3;"a" ，"b" ，"c";"d" ，"e" ，"f"} ，2，TRUE) 返回“ c”。

### INDEX 

>  INDEX（在哪儿找，第几行）

- 用途： 返回表格或区域中的数值或对数值的引用。函数 INDEX() 有两种形式 : 数组和引 用。数组形式通常返回数值或数值数组 ;引用形式通常返回引用。
-  语法：
  -  INDEX(array ，row_num，column_num)返回数组中指定的单元格或单元格数组的 数值。
  -  INDEX(reference ，row_num，column_num，area_num) 返回引用中指定单元格或单元 格区域的引用。
- 参数：
  - Array 为单元格区域或数组常数 ;
  - Row_num为数组中某行的行序号， 函数从该行返 回数值。如果省略 row_num，则必须有 column_num;
  - Column_num是数组中某列的列序号，函 数从该列返回数值。如果省略 column_num，则必须有 row_num。
  - Reference 是对一个或多个 单元格区域的引用， 如果为引用输入一个不连续的选定区域， 必须用括号括起来。
  -  Area_num 是选择引用中的一个区域，并返回该区域中 row_num和 column_num的交叉区域。选中或输 入的第一个区域序号为 1，第二个为 2，以此类推。如果省略 area_num，则 INDEX函数使用 区域 1。
- 实例：如果 A1=68、A2=96、A3=90，则公式“=INDEX(A1:A3， 1，1) ”返回 68，=INDEX(A1:A3， 1，1，1) 返回 68。

### LOOKUP

- 用途： 返回向量 (单行区域或单列区域 )或数组中的数值。该函数有两种语法形式 : 向量 和数组， 其向量形式是在单行区域或单列区域 ( 向量)中查找数值， 然后返回第二个单行区域 或单列区域中相同位置的数值 ; 其数组形式在数组的第一行或第一列查找指定的数值，然后 返回数组的最后一行或最后一列中相同位置的数值。
-  语法 1(向量形式 ):LOOKUP(lookup_value ，lookup_vector ，result_vector) 
- 语法 2(数组形式 ):LOOKUP(lookup_value ，array) 。
-  参数 1(向量形式 ):
  - Lookup_value 为函数 LOOKUP在第一个向量中所要查找的数值。 Lookup_value 可以为数字、 文本、逻辑值或包含数值的名称或引用。
  -  Lookup_vector 为只包 含一行或一列的区域。 Lookup_vector 的数值可以为文本、数字或逻辑值。 
- 参数 2(数组形式 ):
  - Lookup_value 为函数 LOOKUP在数组中所要查找的数值。 Lookup_value 可以为数字、文本、逻辑值或包含数值的名称或引用。如果函数 LOOKUP找不 到 lookup_value ，则使用数组中小于或等于 lookup_value 的最大数值。 
  - Array 为包含文本、 数字或逻辑值的单元格区域，它的值用于与 lookup_value 进行比较。 注意 :Lookup_vector 的数值必须按升序排列，否则 LOOKUP函数不能返回正确的结果， 参数中的文本不区分大小写。 
- 实例： 如果 A1=68、A2=76、A3=85、A4=90，则公式“ =LOOKUP(76 ，A1:A4) ”返回 2， =LOOKUP("bump"，{"a" ，1;"b" ，2;"c" ，3}) 返回 2。

### MATCH

> **MATCH函数：**返回指定数值在指定区域中的位置。
>
> =MATCH（找谁，在哪儿找，匹配方式）

- 用途：返回在指定方式下与指定数值匹配的数组中元素的相应位置。 如果需要找出匹配 元素的位置而不是匹配元素本身，则应该使用 MATCH函数。
-  语法： MATCH(lookup_value ，lookup_array ，match_type) 。 
- 参数： 
  - Lookup_value 为需要在数据表中查找的数值，它可以是数值 ( 或数字、文本或逻 辑值 )、对数字、文本或逻辑值的单元格引用。
  -  Lookup_array 是可能包含所要查找的数值的 连续单元格区域， Lookup_array 可以是数组或数组引用 ;
  - Match_type 为数字 -1 、0 或 1，它 说明 Excel 如何在 lookup_array 中查找 lookup_value 。如果 match_type 为 1，函数 MATCH 查找小于或等于 lookup_value 的最大数值。如果 match_type 为 0，函数 MATCH查找等于 lookup_value 的第一个数值。如果 match_type 为-1 ，函数 MATCH查找大于或等于 lookup_value 的最小数值。

- 实例： 如果 A1=68、A2=76、A3=85、A4=90，则公式“ =MATCH(90 ，A1:A5，0) ”返回 3。

**注意 :**MATCH函数返回 lookup_array 中目标值的位置， 而不是数值本身。 如果 match_type 为 0 且 lookup_value 为文本， lookup_value 可以包含通配符 (“*”和“ ?”) 。星号可以匹 配任何字符序列，问号可以匹配单个字符。 

### VLOOKUP函数

函数中最受欢迎的有三大家族，一个是以SUM函数为首的求和家族，一个是以VLOOKUP函数为首的查找引用家族，另外一个就是以IF函数为首的逻辑函数家族。根据二八定律，学好这三大家族的函数，就能完成80%的工作。

现在一起来学习VLOOKUP函数，让关于查找的烦恼一次全解决！

1、根据番号精确查找俗称。

![img](.\excel.assets\u=266526541,1343919108&fm=173&app=25&f=JPEG)



=VLOOKUP(D2,A:B,2,0)

VLOOKUP函数语法：

=VLOOKUP(查找值,查找区域,返回查找区域第N列,查找模式)

VLOOKUP函数示意图。

![img](.\excel.assets\u=1601737953,2478238561&fm=173&app=25&f=JPEG)



2、屏蔽错误值错误值查找。

![img](.\excel.assets\u=2760062249,990407702&fm=173&app=25&f=JPEG)



=VLOOKUP(D2,A:B,2,0)

VLOOKUP函数如果查找不到对应值会显示错误值#N/A，这个看起来很不美观。这时可以在外面加个容错函数IFERROR，如果是2013版本那就更好，可以用IFNA函数，这个是专门处理#N/A这种错误值。

=IFERROR(VLOOKUP(D2,A:B,2,0),"")=IFNA(VLOOKUP(D2,A:B,2,0),"")

函数语法：

=IFERROR(表达式,错误值要显示的结果)

说白了就是将错误值显示成你想要的结果，不是错误值就返回原来的值。IFNA函数的作用也是一样，只是IFERROR函数是针对所有错误值，而IFNA函数只针对#N/A。

3、按顺序返回多列对应值。

![img](.\excel.assets\u=1136311748,3071726032&fm=173&app=25&f=JPEG)



通过上面的例子，我们知道可以通过更改第3参数，返回各项对应值如：

=VLOOKUP($A13,$A$1:$F$10,2,0)=VLOOKUP($A13,$A$1:$F$10,3,0)

如果项目少，更改几次参数也没什么，但项目多时，肯定不方便。如图 5103所示，可以通过ROW、COLUMN产生行列号，从而得到1，2，……，n的值。

![img](.\excel.assets\u=2894384098,1613858401&fm=173&app=25&f=JPEG)



=VLOOKUP($A13,$A$1:$F$10,COLUMN(B1),0)

因为这里是同一行产生序号，所以用COLUMN函数。

4、按不同顺序返回对应值。

![img](.\excel.assets\u=1243470361,3731769728&fm=173&app=25&f=JPEG)



这回看来只能手动更改第3参数了，COLUMN完全派不上用场。

NO！每当你觉得操作繁琐时，就要停下来思考，也许Excel本身存在这个功能，只是自己一时想不到或者不知道而已。列号不管千变万化，在数据源的位置始终不变，利用这个特点可以去搜索一下看看有什么函数可以解决。

在“搜索函数”文本框输入：位置，单击“转到”按钮，就会出现跟位置有关的函数，查看每个函数的说明，找到我们需要的，如MATCH函数，返回符合特定值特定顺序的项在数组中的相应位置，单击“确定”按钮。

![img](.\excel.assets\u=331641044,3372566280&fm=173&app=25&f=JPEG)



在弹出的“函数参数对话框”中尝试填写相应的参数，每个参数的作用下面都有相关说明，填写后会出现计算结果3，也就是订单数在区域中是第3列。尝试下更改第1参数为C12（俗称），计算结果是2，也就是区域中第2列。经过尝试，知道这个函数是我们要找的那个函数，单击“取消”按钮，返回工作表。

![img](.\excel.assets\u=2704640403,1921247121&fm=173&app=25&f=JPEG)



在单元格再做最后一次验证。

![img](.\excel.assets\u=3601771843,286904903&fm=173&app=25&f=JPEG)



到这一步已经十拿九稳了，将公式设置为：

=VLOOKUP($A13,$A$1:$F$10,MATCH(B$12,$A$1:$F$1,0),0)

5、根据番号逆序俗称。

![img](.\excel.assets\u=1053004440,1439394330&fm=173&app=25&f=JPEG)



帮助提到VLOOKUP函数只能按首列查找，不能逆向查找，既然如此，那就得想办法将非首列的区域转换成首列。怎么转换区域呢，这时IF函数就派上用场。一步步来了解IF函数的转换。

看看好友传递如何趣聊IF函数，吃货的福音。

IF函数其实只有一个条件来判断是否符合条件，返回FALSE和TRUE两种结果。

当菜只有分甜的或咸的2种口味时，甜味是红烧肉，咸味是酱油肉。

![img](.\excel.assets\u=1593382535,642041370&fm=173&app=25&f=JPEG)



盲人吃饭时，看不到是什么菜。当别人问盲人：“你现在吃的什么菜？ 是咸的吗？如果是咸的，就是酱油肉，如果不是咸的就是红烧肉。”（给定判断条件：咸味）盲人刚好在吃红烧肉，于是就咂吧着嘴说：“恩，好吃，不是咸的！是红烧肉”（根据提问的要求，不符合咸的）假如要是盲人当时是在吃酱油肉呢,一定回答；“是的，咸的，是酱油肉”（条件为真，是！TRUE）。盲人根据口感，结合提问者说的条件，就知道自己吃的是红烧肉还是酱油肉了。

把这段话用公式来写：

=IF(A1="咸的",A2,B2)

翻译：是咸的吗？要是（TRUE），就是酱油肉，要是不是咸的（FALSE），就是甜的红烧肉。

A1="咸的"这个条件也可以直接换成TRUE或者FALSE。

=IF(TRUE,A2,B2)

因为满足条件，所以返回A2的对应值酱油肉。

=IF(FALSE,A2,B2)

因为不满足条件，所以返回B2的对应值红烧肉。

其实TRUE=1，FALSE=0，所以可以直接用1跟0表示。

=IF(1,A2,B2)=IF(0,A2,B2)

IF函数不止可以返回1个单元格的值，也可以返回多个单元格的值。

=IF({1,0},A2,B2)=IF({0,1},A2,B2)

选择两个单元格输入，按Ctrl+Shift+Enter三键结束。条件为{1,0}，返回A2:B2的对应值顺序不变；条件为{0,1}，返回A2:B2的对应值，顺序对换。也就是说通过改变1跟0的位置，可以调换两单元格的前后位置。

![img](.\excel.assets\u=146597669,4125345484&fm=173&app=25&f=JPEG)



看到这里，知道IF函数通过改变1,0可以调换单元格的顺序，如果要改变区域的顺序也是可以实现的。

用IF函数重新构造的新区域，是多单元格数组公式，记得按Ctrl+Shift+Enter三键结束，否则出错。

![img](.\excel.assets\u=2814522260,3725793300&fm=173&app=25&f=JPEG)



新区域：

=IF({1,0},B2:B10,A2:A10)

所以公式可以变成：

=VLOOKUP(A13,新区域,2,0)

两个公式合并，大功告成。

=VLOOKUP(A13,IF({1,0},$B$2:$B$10,$A$2:$A$10),2,0)

6、根据俗称跟订单号两个条件查询完成情况。

![img](.\excel.assets\u=3327130150,777880219&fm=173&app=25&f=JPEG)



正常情况下VLOOKUP函数是不能多条件查询，通过IF函数的学习，我们知道IF函数可以重新构造区域，这里就再次用IF构成一个区域。

![img](.\excel.assets\u=1436993710,203263381&fm=173&app=25&f=JPEG)



新区域：

=IF({1,0},A2:A9&C2:C9,E2:E9)

所以公式可以变成：

=VLOOKUP(A12&B12,新区域,2,0)

两个公式合并，大功告成，记得按Ctrl+Shift+Enter三键结束。

=VLOOKUP(A12&B12,IF({1,0},$A$2:$A$9&$C$2:$C$9,$E$2:$E$9),2,0)

7、根据俗称的第一个字符查找番号。

![img](.\excel.assets\u=4101657032,1471937523&fm=173&app=25&f=JPEG)



=VLOOKUP(D2&"*",A:B,2,0)

星号（*）是通配符，代表所有字符，问号（?）代表一个字符。D2&"*"就是开头包含D2的意思。

8、根据区域判断成绩的等级。

![img](.\excel.assets\u=2996659169,4167936787&fm=173&app=25&f=JPEG)



借助辅助列的话，很容易查询等级，只需将VLOOKUP函数的第四参数设置为1或者省略即可。

=VLOOKUP(E2,A:C,3)

如果不用辅助列，估计很多人看到这条公式就得哭了，得结合前面所有函数知识才能完成，有兴趣的朋友可以自己去研究。

=VLOOKUP(E2,IF({1,0},--LEFT(B$2:B$5,FIND("-",B$2:B$5)-1),C$2:C$5),2)

前阵子无意间发现了IMREAL函数，所以不用辅助列的数组公式可以稍微简单一点。

=VLOOKUP(E2,IF({1,0},IMREAL(B$2:B$5&"i"),C$2:C$5),2)

IMREAL函数是计算复数的实部系数的函数，作用就是提取区间的下限。

通过这8个疑难，基本上的查询问题都能够解决。

### OFFSET函数

说起OFFSET函数，真的是像雾像雨又像风，从复杂的数据汇总、到数据透视表再到高级动态图表，都离不开**OFFSET函数**的默默付出。

通过OFFSET函数，可以生成数据区域的动态引用，这个引用再作为半成品，通过后续的处理加工，就可以为图表和透视表提供动态的数据源、为其他函数生成特定的引用了。

首先，咱们说说这个函数的作用，微软的帮助文件是这样描述的：

以指定的引用为参照系，通过给定偏移量返回新的引用。

瞧瞧，这么简单的几句话，让人家怎么能猜透你的心思嘛。

这个函数有5个参数：

第一个参数是基点

第二个参数是要偏移几行，正数向下，负数向上。

第三个参数是要偏移几列，正数向右，负数向左。

第四个参数是新引用几行。

第五个参数是新引用几列。

如果不使用第四个和第五个参数，新引用的区域就是和基点一样的大小。

如果使用下面这个公式：

=OFFSET(C3,4,2,4,3)

就是以C3为基点，向下偏移4行，向右偏移2列，新引用的行数是4行，新引用的列数是3列，最终得到对E7:G10单元格区域的引用。

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-15112215210b19.jpg)

当然，仅仅得到引用是没啥用处的，咱们的目的是把OFFSET函数得到的引用作为一个半成品，再通过其他方法进行再加工。

这么说还是有点抽象啊，再来一个形象一点的：

OFFSET函数就像是一个鬼子小分队，从据点董家庄(C3)出动，顺着大路向南走4里(C7)

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-151122152124510.jpg)

拐弯儿再向东2里，这时候就到马家河子(E7)了

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-15112215213DF.jpg)

鬼子队长说了，我要以马家河子(E7)这个地方开始，再占领一片地盘。有多大呢?向南4里，向东3里。

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-15112215214a95.jpg)

吆西，结果就是E7:G10单元格区域了。

简单认识了OFFSET函数，咱们再用一个动态图表的制作，来说说OFFSET函数的实际应用。

OFFSET函数和动态图表之间，属于是“见不得人”的关系。

所谓动态图表，就是能根据指定的条件，自动变化图表数据源，使图表能够按照我们指定的规则，动态显示数据中的重点关注部分。

说“见不得人”，是指不能在图表中直接使用OFFSET函数，而是要将OFFSET函数先定义成名称，然后在图表中使用自定义名称作为数据源。

看下面这个题目：

这个销售流水记录中，每天都要不断的添加数据。现在要制作一个图表，仅展示最近7天的销售状况。

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-151122152203E4.jpg)

首先，在【公式】选项卡下，单击【定义名称】，分别定义两个名称：

日期=OFFSET($A$1,COUNT($A:$A),0,-7)

销售额=OFFSET($B$1,COUNT($A:$A),0,-7)

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-15112215221D58.jpg)

说说定义名称日期这个公式的意思：

COUNT函数对A列数值计数，结果作为OFFSET函数的行偏移参数。

OFFSET函数以A1为基点，向下偏移的行数是COUNT的结果，也就是A列有多少个数值，就向下偏移多少行。

这时候就相当于到了A列数值的最后一行，给定的偏移列数是0，新引用的行数是-7，得到从A列数值的最后一行开始，向上7行这样一个动态的区域。

如果A列的数值增加了，COUNT函数的计数结果就增加了，OFFSET函数的行偏移参数也就随之变化。

就相当于一竿子捅到底，然后来个烧鸡大窝脖儿，向上引用7行，所以得到的始终是最后7行的引用。

接下来，按下图步骤插入一个柱形图。

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-15112215222QV.jpg)

右键单击数据系列，选择数据源

![图文实例详解OFFSET函数的使用方法](.\excel.assets\1-15112215223b26.jpg)

设置数据系列的系列值为：

=Sheet2!销售额

这里的Sheet2，是数据源工作表的名称。销售额，就是定义的名称。

设置轴标签的区域为：

=Sheet2!日期

## 一般统计函数

### COUNT

- 用途： 返回数字参数的个数。它可以统计数组或单元格区域中含有数字的单元格个数。 
- 语法： COUNT(value1，value2 ，...) 。
-  参数： value1 ，value2 ，... 是包含或引用各种类型数据的参数 (1～30 个) ，其中只有 数字类型的数据才能被统计。
-  实例： 如果 A1=90、A2=人数、 A3=〞〞、 A4=54、A5=36，则公式“ =COUNT(A1:A5)”返 回 3。

### COUNTIF 

- 用途： 计算区域中满足给定条件的单元格的个数。 

- 语法： COUNTIF(range，criteria) 

- 参数：Range为需要计算其中满足条件的单元格数目的单元格区域。 Criteria 为确定哪 些单元格将被计算在内的条件，其形式可以为数字、表达式或文本。

### LARGE 

- 用途： 返回某一数据集中的某个最大值。可以使用 LARGE函数查询考试分数集中第一、 第二、第三等的得分。 语法： LARGE(array，k) 
- 参数： Array 为需要从中查询第 k 个最大值的数组或数据区域， K为返回值在数组或数 据单元格区域里的位置 (即名次 )。 
- 实例：如果 B1=59、B2=70、B3=80、B4=90、B5=89、B6=84、B7=92，，则公式“=LARGE(B1， B7，2) ”返回 90。

### MAX

- 用途： 返回数据集中的最大数值。 语法： MAX(number1，number2，...) 
- 参数： Number1，number2，... 是需要找出最大数值的 1 至 30 个数值。 
- 实例：如果 A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，则公式“=MAX(A1:A7)” 返回 96。

### MIN

- 用途： 返回给定参数表中的最小值。 语法： MIN(number1，number2，...) 。 
- 参数： Number1，number2，... 是要从中找出最小值的 1 到 30 个数字参数。 
- 实例：如果 A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，则公式“=MIN(A1:A7) ” 返回 49; 而=MIN(A1:A5，0，-8) 返回 -8。

### RANK

- 用途： 返回一个数值在一组数值中的排位 ( 如果数据清单已经排过序了，则数值的排位 就是它当前的位置 )。

- 语法： RANK(number，ref ，order)

- 参数：Number是需要计算其排位的一个数字 ;Ref 是包含一组数字的数组或引用 (其中的 非数值型参数将被忽略 );Order 为一数字，指明排位的方式。如果 order 为 0 或省略，则按 降序排列的数据清单进行排位。如果 order 不为零， ref 当作按升序排列的数据清单进行排 位。 注意： 函数 RANK对重复数值的排位相同。但重复数的存在将影响后续数值的排位。如 在一列整数中， 若整数 60 出现两次， 其排位为 5，则 61 的排位为 7( 没有排位为 6 的数值 )。

- 实例： 如果 A1=78、A2=45、A3=90、A4=12、A5=85，则公式“ =RANK(A1，$A$1:$A$5) ” 返回 5、8、2、10、4。

### SMALL

- 用途： 返回数据集中第 k 个最小值，从而得到数据集中特定位置上的数值。 
- 语法： SMALL(array ，k) 
- 参数： Array 是需要找到第 k 个最小值的数组或数字型数据区域， K为返回的数据在数 组或数据区域里的位置 (从小到大 ) 。 
- 实例： 如果如果 A1=78、A2=45、A3=90、A4=12、A5=85，则公式“ =SMALL(A1:A5，3)” 返回 78。

### FIXED 

- 用途： 按指定的小数位数四舍五入一个数，以小数格式设置后以文字串形式返回结果。 
- 语法： FIXED(number，decimals ，no_commas)。
-  参数：Number是要进行四舍五入并转换成文字串的数 ;Decimals 为一数值， 用以指定小 数点右边的小数位数 ;No_commas为一逻辑值。如果是 TRUE，则函数 FIXED 返回的文字不含 逗号。如果 no_commas是 FALSE或省略，则返回的文字中包含逗号。 
- 实例： 如果 A1=2001.16845，则公式“ =FIXED(A2，2，TRUE)”返回 2001.17 ， =FIXED(6834.567 ，-1) 返回 6830。

### AVEDEV

**用途：**返回一组数据与其平均值的绝对偏差的平均值，该函数可以评测数据(例如学生的某科考试成绩)的离散度。

**语法：**AVEDEV(number1，number2，...)

**参数：**Number1、number2、...是用来计算绝对偏差平均值的一组参数，其个数可以在1～30个之间。

**实例：**如果A1=79、A2=62、A3=45、A4=90、A5=25，则公式“=AVEDEV(A1:A5)”返回20.16。

### AVERAGE

**用途：**计算所有参数的算术平均值。

**语法：**AVERAGE(number1，number2，...)。

**参数：**Number1、number2、...是要计算平均值的1～30个参数。

**实例：**如果A1:A5区域命名为分数，其中的数值分别为100、70、92、47和82，则公式“=AVERAGE(分数)”返回78.2。

### **AVERAGEA**

**用途：**计算参数清单中数值的平均值。它与AVERAGE函数的区别在于不仅数字，而且文本和逻辑值(如TRUE和FALSE)也参与计算。

**语法：**AVERAGEA(value1，value2，...)

**参数：**value1、value2、...为需要计算平均值的1至30个单元格、单元格区域或数值。

**实例：**如果A1=76、A2=85、A3=TRUE，则公式“=AVERAGEA(A1:A3)”返回54(即76+85+1/3=54)。

### **BETADIST**

**用途：**返回Beta分布累积函数的函数值。Beta分布累积函数通常用于研究样本集合中某些事物的发生和变化情况。例如，人们一天中看电视的时间比率。

**语法：**BETADIST(x，alpha，beta，A，B)

**参数：**X用来进行函数计算的值，须居于可选性上下界(A和B)之间。Alpha分布的参数。Beta分布的参数。A是数值x所属区间的可选下界，B是数值x所属区间的可选上界。

**实例：**公式“=BETADIST(2，8，10，1，3)”返回0.685470581。

### **BETAINV**

**用途：**返回beta分布累积函数的逆函数值。即，如果probability=BETADIST(x，...)，则BETAINV(probability，...)=x。beta分布累积函数可用于项目设计，在给出期望的完成时间和变化参数后，模拟可能的完成时间。

**语法：**BETAINV(probability，alpha，beta，A，B)

**参数：**Probability为Beta分布的概率值，Alpha分布的参数，Beta分布的参数，A数值x所属区间的可选下界，B数值x所属区间的可选上界。

**实例：**公式“=BETAINV(0.685470581，8，10，1，3)”返回2。

### **BINOMDIST**

**用途：**返回一元二项式分布的概率值。BINOMDIST函数适用于固定次数的独立实验，实验的结果只包含成功或失败二种情况，且成功的概率在实验期间固定不变。例如，它可以计算掷10次硬币时正面朝上6次的概率。

**语法：**BINOMDIST(number_s，trials，probability_s，cumulative)

**参数：**Number_s为实验成功的次数，Trials为独立实验的次数，Probability_s为一次实验中成功的概率，Cumulative是一个逻辑值，用于确定函数的形式。如果cumulative为TRUE，则BINOMDIST函数返回累积分布函数，即至多 number_s次成功的概率;如果为FALSE，返回概率密度函数，即number_s次成功的概率。

**实例：**抛硬币的结果不是正面就是反面，第一次抛硬币为正面的概率是0.5。则掷硬币10次中6次的计算公式为“=BINOMDIST(6，10，0.5，FALSE)”，计算的结果等于0.205078

### **CHIDIST**

**用途：**返回c2分布的单尾概率。c2分布与c2检验相关。使用c2检验可以比较观察值和期望值。例如，某项遗传学实验假设下一代植物将呈现出某一组颜色。使用此函数比较观测结果和期望值，可以确定初始假设是否有效。

**语法：**CHIDIST(x，degrees_freedom)

**参数：**X是用来计算c2分布单尾概率的数值，Degrees_freedom是自由度。

**实例：**公式“=CHIDIST(1，2)”的计算结果等于0.606530663。

### **CHIINV**

**用途：**返回c2分布单尾概率的逆函数。如果probability=CHIDIST(x，?)，则CHIINV(probability，?)=x。使用此函数比较观测结果和期望值，可以确定初始假设是否有效。

**语法：**CHIINV(probability，degrees_freedom)

**参数：**Probability为c2分布的单尾概率，Degrees_freedom为自由度。

**实例：**公式“=CHIINV(0.5，2)”返回1.386293564。

### **CHITEST**

**用途：**返回相关性检验值，即返回c2分布的统计值和相应的自由度，可使用c2检验确定假设值是否被实验所证实。

**语法：**CHITEST(actual_range，expected_range)

**参数：**Actual_range是包含观察值的数据区域，Expected_range是包含行列汇总的乘积与总计值之比的数据区域。

**实例：**如果A1=1、A2=2、A3=3、B1=4、B2=5、B3=6，则公式“=CHITEST(A1:A3，B1:B3)”返回0.062349477。

### **CONFIDENCE**

**用途：**返回总体平均值的置信区间，它是样本平均值任意一侧的区域。例如，某班学生参加考试，依照给定的置信度，可以确定该次考试的最低和最高分数。

**语法：**CONFIDENCE(alpha，standard_dev，size)。

**参数：**Alpha是用于计算置信度(它等于100*(1-alpha)%，如果alpha为0.05，则置信度为95%)的显著水平参数，Standard_dev是数据区域的总体标准偏差，Size为样本容量。

**实例：**假设样本取自46名学生的考试成绩，他们的平均分为60，总体标准偏差为5分，则平均分在下列区域内的置信度为95%。公式“=CONFIDENCE(0.05，5，46)”返回1.44，即考试成绩为60±1.44分。

### **CORREL**

**用途：**返回单元格区域array1和array2之间的相关系数。它可以确定两个不同事物之间的关系，例如检测学生的物理与数学学习成绩之间是否关联。

**语法：**CORREL(array1，array2)

**参数：**Array1第一组数值单元格区域。Array2第二组数值单元格区域。

**实例：**如果A1=90、A2=86、A3=65、A4=54、A5=36、B1=89、B2=83、B3=60、B4=50、B5=32，则公式“=CORREL(A1:A5，B1:B5)”返回0.998876229，可以看出A、B两列数据具有很高的相关性。

### **COUNT**

**用途：**返回数字参数的个数。它可以统计数组或单元格区域中含有数字的单元格个数。

**语法：**COUNT(value1，value2，...)。

**参数：**value1，value2，...是包含或引用各种类型数据的参数(1～30个)，其中只有数字类型的数据才能被统计。

**实例：**如果A1=90、A2=人数、A3=〞〞、A4=54、A5=36，则公式“=COUNT(A1:A5)”返回3。

### **COUNTA**

**用途：**返回参数组中非空值的数目。利用函数COUNTA可以计算数组或单元格区域中数据项的个数。

**语法：**COUNTA(value1，value2，...)

说明:value1，value2，...所要计数的值，参数个数为1～30个。在这种情况下的参数可以是任何类型，它们包括空格但不包括空白单元格。如果参数是数组或单元格引用，则数组或引用中的空白单元格将被忽略。如果不需要统计逻辑值、文字或错误值，则应该使用COUNT函数。

**实例：**如果A1=6.28、A2=3.74，其余单元格为空，则公式“=COUNTA(A1:A7)”的计算结果等于2。

### **COUNTBLANK**

**用途：**计算某个单元格区域中空白单元格的数目。

**语法：**COUNTBLANK(range)

**参数：**Range为需要计算其中空白单元格数目的区域。

**实例：**如果A1=88、A2=55、A3=""、A4=72、A5=""，则公式“=COUNTBLANK(A1:A5)”返回2。

### **COUNTIF**

**用途：**计算区域中满足给定条件的单元格的个数。

**语法：**COUNTIF(range，criteria)

**参数：**Range为需要计算其中满足条件的单元格数目的单元格区域。Criteria为确定哪些单元格将被计算在内的条件，其形式可以为数字、表达式或文本。

### **COVAR**

**用途：**返回协方差，即每对数据点的偏差乘积的平均数。利用协方差可以研究两个数据集合之间的关系。

**语法：**COVAR(array1，array2)

**参数：**Array1是第一个所含数据为整数的单元格区域，Array2是第二个所含数据为整数的单元格区域。

**实例：**如果A1=3、A2=2、A3=1、B1=3600、B2=1500、B3=800，则公式“=COVAR(A1:A3，B1:B3)”返回933.3333333。

### **CRITBINOM**

**用途：**返回使累积二项式分布大于等于临界值的最小值，其结果可以用于质量检验。例如决定最多允许出现多少个有缺陷的部件，才可以保证当整个产品在离开装配线时检验合格。

**语法：**CRITBINOM(trials，probability_s，alpha)

**参数：**Trials是伯努利实验的次数，Probability_s是一次试验中成功的概率，Alpha是临界值。

**实例：**公式“=CRITBINOM(10，0.9，0.75)”返回10。

### **DEVSQ**

**用途：**返回数据点与各自样本平均值的偏差的平方和。

**语法：**DEVSQ(number1，number2，...)

**参数：**Number1、number2、...是用于计算偏差平方和的1到30个参数。它们可以是用逗号分隔的数值，也可以是数组引用。

**实例：**如果A1=90、A2=86、A3=65、A4=54、A5=36，则公式“=DEVSQ(A1:A5)”返回2020.8。

### **EXPONDIST**

**用途：**返回指数分布。该函数可以建立事件之间的时间间隔模型，如估计银行的自动取款机支付一次现金所花费的时间，从而确定此过程最长持续一分钟的发生概率。

**语法：**EXPONDIST(x，lambda，cumulative)。

**参数：**X函数的数值，Lambda参数值，Cumulative为确定指数函数形式的逻辑值。如果cumulative为TRUE，EXPONDIST返回累积分布函数;如果cumulative为FALSE，则返回概率密度函数。

**实例：**公式“=EXPONDIST(0.2，10，TRUE)”返回0.864665，=EXPONDIST(0.2，10，FALSE)返回1.353353。

### **FDIST**

**用途：**返回F概率分布，它可以确定两个数据系列是否存在变化程度上的不同。例如，通过分析某一班级男、女生的考试分数，确定女生分数的变化程度是否与男生不同。

**语法：**FDIST(x，degrees_freedom1，degrees_freedom2)

**参数：**X是用来计算概率分布的区间点，Degrees_freedom1是分子自由度，Degrees_freedom2是分母自由度。

**实例：**公式“=FDIST(1，90，89)”返回0.500157305。

### **FINV**

**用途：**返回F概率分布的逆函数值，即F分布的临界值。如果p=FDIST(x，…)，则FINV(p，…)=x。

**语法：**FINV(probability，degrees_freedom1，degrees_freedom2)

**参数：**Probability是累积F分布的概率值，Degrees_freedom1是分子自由度，Degrees_freedom2是分母自由度。

**实例：**公式“=FINV(0.1，86，74)”返回1.337888023。

### **FISHER**

**用途：**返回点x的Fisher变换。该变换生成一个近似正态分布而非偏斜的函数，使用此函数可以完成相关系数的假设性检验。

**语法：**FISHER(x)

**参数：**X为一个数字，在该点进行变换。

**实例：**公式“=FISHER(0.55)”返回0.618381314。

### **FISHERINV**

**用途：**返回Fisher变换的逆函数值，如果y=FISHER(x)，则FISHERINV(y)=x。上述变换可以分析数据区域或数组之间的相关性。

**语法：**FISHERINV(y)

**参数：**Y为一个数值，在该点进行反变换。

**实例：**公式“=FISHERINV(0.765)”返回0.644012628。

### **FORECAST**

**用途：**根据一条线性回归拟合线返回一个预测值。使用此函数可以对未来销售额、库存需求或消费趋势进行预测。

**语法：**FORECAST(x，known_y’s，known_x’s)。

**参数：**X为需要进行预测的数据点的X坐标(自变量值)。Known_y’s是从满足线性拟合直线y=kx+b的点集合中选出的一组已知的y值，Known_x’s是从满足线性拟合直线y=kx+b的点集合中选出的一组已知的x值。

**实例：**公式“=FORECAST(16，{7，8，9，11，15}，{21，26，32，36，42})”返回4.378318584。

### **FREQUENCY**

**用途：**以一列垂直数组返回某个区域中数据的频率分布。它可以计算出在给定的值域和接收区间内，每个区间包含的数据个数。

**语法：**FREQUENCY(data_array，bins_array)

**参数：**Data_array是用来计算频率一个数组，或对数组单元区域的引用。Bins_array是数据接收区间，为一数组或对数组区域的引用，设定对data_array进行频率计算的分段点。

### FTEST

**用途：**返回F检验的结果。它返回的是当数组1和数组2的方差无明显差异时的单尾概率，可以判断两个样本的方差是否不同。例如，给出两个班级同一学科考试成绩，从而检验是否存在差别。

**语法：**FTEST(array1，array2)

**参数：**Array1是第一个数组或数据区域，Array2是第二个数组或数据区域。

**实例：**如果A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，B1=59、B2=70、B3=80、B4=90、B5=89、B6=84、B7=92，则公式“=FTEST(A1:A7，B1:B7)”返回0.519298931。

### **GAMMADIST**

**用途：**返回伽玛分布。可用它研究具有偏态分布的变量，通常用于排队分析。

**语法：**GAMMADIST(x，alpha，beta，cumulative)。

**参数：**X为用来计算伽玛分布的数值，Alpha是γ分布参数，Betaγ分布的一个参数。如果beta=1，GAMMADIST 函数返回标准伽玛分布。Cumulative为一逻辑值，决定函数的形式。如果cumulative为TRUE，GAMMADIST函数返回累积分布函数;如果为FALSE，则返回概率密度函数。

**实例：**公式“=GAMMADIST(10，9，2，FALSE)”的计算结果等于0.032639，=GAMMADIST(10，9，2，TRUE)返回0.068094。

### **GAMMAINV**

**用途：**返回具有给定概率的伽玛分布的区间点，用来研究出现分布偏斜的变量。如果P=GAMMADIST(x，...)，则GAMMAINV(p，...)=x。

**语法：**GAMMAINV(probability，alpha，beta)

**参数：**Probability为伽玛分布的概率值，Alphaγ分布参数，Betaγ分布参数。如果beta=1，函数GAMMAINV返回标准伽玛分布。

**实例：**公式“=GAMMAINV(0.05，8，2)”返回7.96164386。

### **GAMMALN**

**用途：**返回伽玛函数的自然对数Γ(x)。

**语法：**GAMMALN(x)

**参数：**X为需要计算GAMMALN函数的数值。

**实例：**公式“=GAMMALN(6)”返回4.787491743。

### **GEOMEAN**

**用途：**返回正数数组或数据区域的几何平均值。可用于计算可变复利的平均增长率。

**语法：**GEOMEAN(number1，number2，...)

**参数：**Number1，number2，...为需要计算其平均值的1到30个参数，除了使用逗号分隔数值的形式外，还可使用数组或对数组的引用。

**实例：**公式“=GEOMEAN(1.2，1.5，1.8，2.3，2.6，2.8，3)”的计算结果是2.069818248。

### **GROWTH**

**用途：**给定的数据预测指数增长值。根据已知的x值和y值，函数GROWTH返回一组新的x值对应的y值。通常使用GROWTH函数拟合满足给定x值和y值的指数曲线。

**语法：**GROWTH(known_y’s，known_x’s，new_x’s，const)

**参数：**Known_y’s是满足指数回归拟合曲线y=b*m^x的一组已知的y值;Known_x’s是满足指数回归拟合曲线 y=b*m^x的一组已知的x值的集合(可选参数);New_x’s是一组新的x值，可通过GROWTH函数返回各自对应的y值;Const为一逻辑值，指明是否将系数b强制设为1，如果const为TRUE或省略，b将参与正常计算。如果const为FALSE，b将被设为1，m值将被调整使得 y=m^x。

### **HARMEAN**

**用途：**返回数据集合的调和平均值。调和平均值与倒数的算术平均值互为倒数。调和平均值总小于几何平均值，而几何平均值总小于算术平均值。

**语法：**HARMEAN(number1，number2，...)

**参数：**Number1，number2，...是需要计算其平均值的1到30个参数。可以使用逗号分隔参数的形式，还可以使用数组或数组的引用。

**实例：**公式“=HARMEAN(66，88，92)”返回80.24669604。

### **HYPGEOMDIST**

**用途：**返回超几何分布。给定样本容量、样本总体容量和样本总体中成功的次数，HYPGEOMDIST函数返回样本取得给定成功次数的概率。

**语法：**HYPGEOMDIST(sample_s，number_sample，population_s，number_population)

**参数：**Sample_s为样本中成功的次数，Number_sample为样本容量。Population_s为样本总体中成功的次数，Number_population为样本总体的容量。

**实例：**如果某个班级有42名学生。其中22名是男生，20名是女生。如果随机选出6人，则其中恰好有三名女生的概率公式是:“=HYPGEOMDIST(3，6，20，42)”，返回的结果为0.334668627。

### **INTERCEPT**

**用途：**利用已知的x值与y值计算直线与y轴的截距。当已知自变量为零时，利用截距可以求得因变量的值。

**语法：**INTERCEPT(known_y’s，known_x’s)

**参数：**Known_y’s是一组因变量数据或数据组，Known_x’s是一组自变量数据或数据组。

**实例：**如果A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，B1=59、B2=70、B3=80、B4=90、B5=89、B6=84、B7=92，则公式“=INTERCEPT(A1:A7，B1:B7)”返回87.61058785。

### **KURT**

**用途：**返回数据集的峰值。它反映与正态分布相比时某一分布的尖锐程度或平坦程度，正峰值表示相对尖锐的分布，负峰值表示相对平坦的分布。

**语法：**KURT(number1，number2，...)

**参数：**Number1，number2，...为需要计算其峰值的1到30个参数。它们可以使用逗号分隔参数的形式，也可以使用单一数组，即对数组单元格的引用。

**实例：**如果某次学生考试的成绩为A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，则公式“=KURT(A1:A7)”返回-1.199009798，说明这次的成绩相对正态分布是一比较平坦的分布。

### **LARGE**

**用途：**返回某一数据集中的某个最大值。可以使用LARGE函数查询考试分数集中第一、第二、第三等的得分。

**语法：**LARGE(array，k)

**参数：**Array为需要从中查询第k个最大值的数组或数据区域，K为返回值在数组或数据单元格区域里的位置(即名次)。

**实例：**如果B1=59、B2=70、B3=80、B4=90、B5=89、B6=84、B7=92，，则公式“=LARGE(B1，B7，2)”返回90。

### **LINEST**

**用途：**使用最小二乘法对已知数据进行最佳直线拟合，并返回描述此直线的数组。

**语法：**LINEST(known_y’s，known_x’s，const，stats)

**参数：**Known_y’s是表达式y=mx+b中已知的y值集合，Known_x’s是关系表达式y=mx+b中已知的可选x值集合，Const为一逻辑值，指明是否强制使常数b为0，如果const为TRUE或省略，b将参与正常计算。如果const为FALSE，b将被设为 0，并同时调整m值使得y=mx。Stats为一逻辑值，指明是否返回附加回归统计值。如果stats为TRUE，函数LINEST返回附加回归统计值。如果stats为FALSE或省略，函数LINEST只返回系数m和常数项b。

**实例：**如果A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，B1=59、B2=70、 B3=80、B4=90、B5=89、B6=84、B7=92，则数组公式“{=LINEST(A1:A7，B1:B7)}”返回 -0.174244885、-0.174244885、-0.174244885、-0.174244885、-0.174244885、 -0.174244885、-0.174244885。

### **LOGEST**

**用途：**在回归分析中，计算最符合观测数据组的指数回归拟合曲线，并返回描述该曲线的数组。

**语法：**LOGEST(known_y’s，known_x’s，const，stats)

**参数：**Known_y’s是一组符合y=b*m^x函数关系的y值的集合，Known_x’s是一组符合y=b*m^x运算关系的可选x值集合，Const是指定是否要设定常数b为1的逻辑值，如果const设定为TRUE或省略，则常数项b将通过计算求得。

**实例：**如果某公司的新产品销售额呈指数增长，依次为A1=33100、A2=47300、A3=69000、 A4=102000、A5=150000和A6=220000，同时B1=11、B2=12、B3=13、B4=14、B5=15、B6=16。则使用数组公式“{=LOGEST(A1:A6，B1:B6，TRUE，TRUE)}”，在C1:D5单元格内得到的计算结果是:1.463275628、 495.3047702、0.002633403、0.035834282、0.99980862、0.011016315、20896.8011、4、 2.53601883和0.000485437。

### **LOGINV**

**用途：**返回x的对数正态分布累积函数的逆函数，此处的ln(x)是含有mean(平均数)与standard-dev(标准差)参数的正态分布。如果p=LOGNORMDIST(x，...)，那么LOGINV(p，...)=x。

**语法：**LOGINV(probability，mean，standard_dev)

**参数：**Probability是与对数正态分布相关的概率，Mean为ln(x)的平均数，Standard_dev为ln(x)的标准偏差。

**实例：**公式“=LOGINV(0.036，2.5，1.5)”返回0.819815949。

### **LOGNORMDIST**

**用途：**返回x的对数正态分布的累积函数，其中ln(x)是服从参数为mean和standard_dev的正态分布。使用此函数可以分析经过对数变换的数据。

**语法：**LOGNORMDIST(x，mean，standard_dev)

**参数：**X是用来计算函数的数值，Mean是ln(x)的平均值，Standard_dev是ln(x)的标准偏差。

**实例：**公式“=LOGNORMDIST(2，5.5，1.6)”返回0.001331107。

### **MAX**

**用途：**返回数据集中的最大数值。

**语法：**MAX(number1，number2，...)

**参数：**Number1，number2，...是需要找出最大数值的1至30个数值。

**实例：**如果A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，则公式“=MAX(A1:A7)”返回96。

### **MAXA**

**用途：**返回数据集中的最大数值。它与MAX的区别在于文本值和逻辑值(如TRUE和FALSE)作为数字参与计算。

**语法：**MAXA(value1，value2，...)

**参数：**value1，value2，...为需要从中查找最大数值的1到30个参数。

**实例：**如果A1:A5包含0、0.2、0.5、0.4和TRUE，则:MAXA(A1:A5)返回1。

### **MEDIAN**

**用途：**返回给定数值集合的中位数(它是在一组数据中居于中间的数。换句话说，在这组数据中，有一半的数据比它大，有一半的数据比它小)。

**语法：**MEDIAN(number1，number2，...)

**参数：**Number1，number2，...是需要找出中位数的1到30个数字参数。

**实例：**MEDIAN(11，12，13，14，15)返回13;MEDIAN(1，2，3，4，5，6)返回3.5，即3与4的平均值。

### **MIN**

**用途：**返回给定参数表中的最小值。

**语法：**MIN(number1，number2，...)。

**参数：**Number1，number2，...是要从中找出最小值的1到30个数字参数。

**实例：**如果A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=96，则公式“=MIN(A1:A7)”返回49;而=MIN(A1:A5，0，-8)返回-8。

### **MINA**

**用途：**返回参数清单中的最小数值。它与MIN函数的区别在于文本值和逻辑值(如TRUE和FALSE)也作为数字参与计算。

**语法：**MINA(value1，value2，...)

**参数：**value1，value2，...为需要从中查找最小数值的1到30个参数。

**实例：**如果A1=71、A2=83、A3=76、A4=49、A5=92、A6=88、A7=FALSE，则公式“=MINA(A1:A7)”返回0。

### **MODE**

**用途：**返回在某一数组或数据区域中的众数。

**语法：**MODE(number1，number2，...)。

**参数：**Number1，number2，...是用于众数计算的1到30个参数。

**实例：**如果A1=71、A2=83、A3=71、A4=49、A5=92、A6=88，则公式“=MODE(A1:A6)”返回71。

### **NEGBINOMDIST**

**用途：**返回负二项式分布。当成功概率为常数probability_s时，函数NEGBINOMDIST返回在到达 number_s次成功之前，出现number_f次失败的概率。此函数与二项式分布相似，只是它的成功次数固定，试验总数为变量。与二项分布类似的是，试验次数被假设为自变量。

**语法：**NEGBINOMDIST(number_f，number_s，probability_s)

Number_f是失败次数，Number_s为成功的临界次数，Probability_s是成功的概率。

**实例：**如果要找10个反应敏捷的人，且已知具有这种特征的候选人的概率为0.3。那么，找到10个合格候选人之前，需要对不合格候选人进行面试的概率公式为“=NEGBINOMDIST(40，10，0.3)”，计算结果是0.007723798。

### **NORMDIST**

**用途：**返回给定平均值和标准偏差的正态分布的累积函数。

**语法：**NORMDIST(x，mean，standard_dev，cumulative)

**参数：**X为用于计算正态分布函数的区间点，Mean是分布的算术平均值，Standard_dev是分布的标准方差;Cumulative为一逻辑值，指明函数的形式。如果cumulative为TRUE，则NORMDIST函数返回累积分布函数;如果为 FALSE，则返回概率密度函数。

**实例：**公式“=NORMDIST(46，35，2.5，TRUE)”返回0.999994583。

### **NORMSINV**

**用途：**返回标准正态分布累积函数的逆函数。该分布的平均值为0，标准偏差为1。

**语法：**NORMSINV(probability)

**参数：**Probability是正态分布的概率值。

**实例：**公式“=NORMSINV(0.8)”返回0.841621386。

### **NORMSDIST**

**用途：**返回标准正态分布的累积函数，该分布的平均值为0，标准偏差为1。

**语法：**NORMSDIST(z)

**参数：**Z为需要计算其分布的数值。

**实例：**公式“=NORMSDIST(1.5)”的计算结果为0.933192771。

### **NORMSINV**

**用途：**返回标准正态分布累积函数的逆函数。该分布的平均值为0，标准偏差为1。

**语法：**NORMSINV(probability)

**参数：**Probability是正态分布的概率值。

**实例：**公式“=NORMSINV(0.933192771)”返回1.499997779(即1.5)。

### **PEARSON**

**用途：**返回Pearson(皮尔生)乘积矩相关系数r，它是一个范围在-1.0到1.0之间(包括-1.0和1.0在内)的无量纲指数，反映了两个数据集合之间的线性相关程度。

**语法：**PEARSON(array1，array2)

**参数：**Array1为自变量集合，Array2为因变量集合。

**实例：**如果A1=71、A2=83、A3=71、A4=49、A5=92、A6=88，B1=69、B2=80、B3=76、B4=40、B5=90、B6=81，则公式“=PEARSON(A1:A6，B1:B6)”返回0.96229628。

### **PERCENTILE**

**用途：**返回数值区域的K百分比数值点。例如确定考试排名在80个百分点以上的分数。

**语法：**PERCENTILE(array，k)

**参数：**Array为定义相对位置的数值数组或数值区域，k为数组中需要得到其排位的值。

**实例：**如果某次考试成绩为A1=71、A2=83、A3=71、A4=49、A5=92、A6=88，则公式“=PERCENTILE(A1:A6，0.8)”返回88，即考试排名要想在80个百分点以上，则分数至少应当为88分。

### **PERCENTRANK**

**用途：**返回某个数值在一个数据集合中的百分比排位，可用于查看数据在数据集中所处的位置。例如计算某个分数在所有考试成绩中所处的位置。

**语法：**PERCENTRANK(array，x，significance)

**参数：**Array为彼此间相对位置确定的数据集合，X为其中需要得到排位的值，Significance为可选项，表示返回的百分数值的有效位数。如果省略，函数PERCENTRANK保留3位小数。

**实例：**如果某次考试成绩为A1=71、A2=83、A3=71、A4=49、A5=92、A6=88，则公式“=PERCENTRANK(A1:A6，71)”的计算结果为0.2，即71分在6个分数中排20%。

### **PERMUT**

**用途：**返回从给定数目的元素集合中选取的若干元素的排列数。

**语法：**PERMUT(number，number_chosen)

**参数：**Number为元素总数，Number_chosen是每个排列中的元素数目。

**实例：**如果某种彩票的号码有9个数，每个数的范围是从0到9(包括0和9)。则所有可能的排列数量用公式“=PERMUT(10，9)”计算，其结果为3628800。

### **POISSON**

**用途：**返回泊松分布。泊松分布通常用于预测一段时间内事件发生的次数，比如一分钟内通过收费站的轿车的数量。

**语法：**POISSON(x，mean，cumulative)

**参数：**X是某一事件出现的次数，Mean是期望值，Cumulative为确定返回的概率分布形式的逻辑值。

**实例：**公式“=POISSON(5，10，TRUE)”返回0.067085963，=POISSON(3，12，FALSE)返回0.001769533。

### **PROB**

**用途：**返回一概率事件组中落在指定区域内的事件所对应的概率之和。

**语法：**PROB(x_range，prob_range，lower_limit，upper_limit)

**参数：**X_range是具有各自相应概率值的x数值区域，Prob_range是与x_range中的数值相对应的一组概率值，Lower_limit是用于概率求和计算的数值下界，Upper_limit是用于概率求和计算的数值可选上界。

**实例：**公式“=PROB({0，1，2，3}，{0.2，0.3，0.1，0.4}，2)”返回0.1，=PROB({0，1，2，3}，{0.2，0.3，0.1，0.4}，1，3)返回0.8。

### **QUARTILE**

**用途：**返回一组数据的四分位点。四分位数通常用于在考试成绩之类的数据集中对总体进行分组，如求出一组分数中前25%的分数。

**语法：**QUARTILE(array，quart)

**参数：**Array为需要求得四分位数值的数组或数字引用区域，Quart决定返回哪一个四分位值。如果qurart取0、1、 2、3或4，则函数QUARTILE返回最小值、第一个四分位数(第25个百分排位)、中分位数(第50个百分排位)、第三个四分位数(第75个百分排位)和最大数值。

**实例：**如果A1=78、A2=45、A3=90、A4=12、A5=85，则公式“=QUARTILE(A1:A5，3)”返回85。

### **RANK**

**用途：**返回一个数值在一组数值中的排位(如果数据清单已经排过序了，则数值的排位就是它当前的位置)。

**语法：**RANK(number，ref，order)

**参数：**Number是需要计算其排位的一个数字;Ref是包含一组数字的数组或引用(其中的非数值型参数将被忽略);Order 为一数字，指明排位的方式。如果order为0或省略，则按降序排列的数据清单进行排位。如果order不为零，ref当作按升序排列的数据清单进行排位。

**注意：**函数RANK对重复数值的排位相同。但重复数的存在将影响后续数值的排位。如在一列整数中，若整数60出现两次，其排位为5，则61的排位为7(没有排位为6的数值)。

**实例：**如果A1=78、A2=45、A3=90、A4=12、A5=85，则公式“=RANK(A1，$A$1:$A$5)”返回5、8、2、10、4。

### **RSQ**

**用途：**返回给定数据点的Pearson乘积矩相关系数的平方。

**语法：**RSQ(known_y’s，known_x’s)

**参数：**Known_y’s为一个数组或数据区域，Known_x’s也是一个数组或数据区域。

**实例：**公式“=RSQ({22，23，29，19，38，27，25}，{16，15，19，17，15，14，34})”返回0.013009334。

### SKEW

**用途：**返回一个分布的不对称度。它反映以平均值为中心的分布的不对称程度，正不对称度表示不对称边的分布更趋向正值。负不对称度表示不对称边的分布更趋向负值。

**语法：**SKEW(number1，number2，...)。

**参数：**Number1，number2...是需要计算不对称度的1到30个参数。包括逗号分隔的数值、单一数组和名称等。

**实例：**公式“=SKEW({22，23，29，19，38，27，25}，{16，15，19，17，15，14，34})”返回0.854631382。

### **SLOPE**

**用途：**返回经过给定数据点的线性回归拟合线方程的斜率(它是直线上任意两点的垂直距离与水平距离的比值，也就是回归直线的变化率)。

**语法：**SLOPE(known_y’s，known_x’s)

**参数：**Known_y’s为数字型因变量数组或单元格区域，Known_x’s为自变量数据点集合。

**实例：**公式“=SLOPE({22，23，29，19，38，27，25}，{16，15，19，17，15，14，34})”返回-0.100680934。

### **SMALL**

**用途：**返回数据集中第k个最小值，从而得到数据集中特定位置上的数值。

**语法：**SMALL(array，k)

**参数：**Array是需要找到第k个最小值的数组或数字型数据区域，K为返回的数据在数组或数据区域里的位置(从小到大)。

**实例：**如果如果A1=78、A2=45、A3=90、A4=12、A5=85，则公式“=SMALL(A1:A5，3)”返回78。

### **STANDARDIZE**

**用途：**返回以mean为平均值，以standard-dev为标准偏差的分布的正态化数值。

**语法：**STANDARDIZE(x，mean，standard_dev)

**参数：**X为需要进行正态化的数值，Mean分布的算术平均值，Standard_dev为分布的标准偏差。

**实例：**公式“=STANDARDIZE(62，60，10)”返回0.2。

### **STDEV**

**用途：**估算样本的标准偏差。它反映了数据相对于平均值(mean)的离散程度。

**语法：**STDEV(number1，number2，...)

**参数：**Number1，number2，...为对应于总体样本的1到30个参数。可以使用逗号分隔的参数形式，也可使用数组，即对数组单元格的引用。

**注意：**STDEV函数假设其参数是总体中的样本。如果数据是全部样本总体，则应该使用STDEVP函数计算标准偏差。同时，函数忽略参数中的逻辑值(TRUE或FALSE)和文本。如果不能忽略逻辑值和文本，应使用STDEVA函数。

**实例：**假设某次考试的成绩样本为A1=78、A2=45、A3=90、A4=12、A5=85，则估算所有成绩标准偏差的公式为“=STDEV(A1:A5)”，其结果等于33.00757489。

### **STDEVA**

**用途：**计算基于给定样本的标准偏差。它与STDEV函数的区别是文本值和逻辑值(TRUE或FALSE)也将参与计算。

**语法：**STDEVA(value1，value2，...)

**参数：**value1，value2，...是作为总体样本的1到30个参数。可以使用逗号分隔参数的形式，也可以使用单一数组，即对数组单元格的引用。

**实例：**假设某次考试的部分成绩为A1=78、A2=45、A3=90、A4=12、A5=85，则估算所有成绩标准偏差的公式为“=STDEVA(A1:A5)”，其结果等于33.00757489。

### **STDEVP**

**用途：**返回整个样本总体的标准偏差。它反映了样本总体相对于平均值(mean)的离散程度。

**语法：**STDEVP(number1，number2，...)

**参数：**Number1，number2，...为对应于样本总体的1到30个参数。可以使用逗号分隔参数的形式，也可以使用单一数组，即对数组单元格的引用。

**注意：**STDEVP函数在计算过程中忽略逻辑值(TRUE或FALSE)和文本。如果逻辑值和文本不能忽略，应当使用STDEVPA函数。

同时STDEVP函数假设其参数为整个样本总体。如果数据代表样本总体中的样本，应使用函数STDEV来计算标准偏差。当样本数较多时，STDEV和STDEVP函数的计算结果相差很小。

**实例：**如果某次考试只有5名学生参加，成绩为A1=78、A2=45、A3=90、A4=12、A5=85，则计算的所有成绩的标准偏差公式为“=STDEVP(A1:A5)”，返回的结果等于29.52287249。

### **STDEVPA**

**用途：**计算样本总体的标准偏差。它与STDEVP函数的区别是文本值和逻辑值(TRUE或FALSE)参与计算。

**语法：**STDEVPA(value1，value2，...)

**参数：**value1，value2，...作为样本总体的1到30个参数。可以使用逗号分隔参数的形式，也可以使用单一数组(即对数组单元格的引用)。

**注意：**STDEVPA函数假设参数为样本总体。如果数据代表的是总体的部分样本，则必须使用STDEVA函数来估算标准偏差。

**实例：**如果某次考试只有5名学生参加，成绩为A1=78、A2=45、A3=90、A4=12、A5=85，则计算的所有成绩的标准偏差公式为“=STDEVP(A1:A5)”，返回的结果等于29.52287249。

### **STEYX**

**用途：**返回通过线性回归法计算y预测值时所产生的标准误差。标准误差用来度量根据单个x变量计算出的y预测值的误差量。

**语法：**STEYX(known_y’s，known_x’s)

**参数：**Known_y’s为因变量数据点数组或区域，Known_x’s为自变量数据点数组或区域。

**实例：**公式“=STEYX({22，13，29，19，18，17，15}，{16，25，11，17，25，14，17})”返回4.251584755。

### **TDIST**

**用途：**返回学生氏t-分布的百分点(概率)，t分布中的数值(x)是t的计算值(将计算其百分点)。t分布用于小样本数据集合的假设检验，使用此函数可以代替t分布的临界值表。

**语法：**TDIST(x，degrees_freedom，tails)

**参数：**X为需要计算分布的数字，Degrees_freedom为表示自由度的整数，Tails指明返回的分布函数是单尾分布还是双尾分布。如果tails=1，函数TDIST返回单尾分布。如果tails=2，函数TDIST返回双尾分布。

**实例：**公式“=TDIST(60，2，1)”返回0.000138831。

### **TINV**

**用途：**返回作为概率和自由度函数的学生氏t分布的t值。

**语法：**TINV(probability，degrees_freedom)

**参数：**Probability为对应于双尾学生氏-t分布的概率，Degrees_freedom为分布的自由度。

**实例：**公式“=TINV(0.5，60)”返回0.678600713。

### **TREND**

**用途：**返回一条线性回归拟合线的一组纵坐标值(y值)。即找到适合给定的数组known_y’s和known_x’s的直线(用最小二乘法)，并返回指定数组new_x’s值在直线上对应的y值。

**语法：**TREND(known_y’s，known_x’s，new_x’s，const)

**参数：**Known_y’s为已知关系y=mx+b中的y值集合，Known_x’s为已知关系y=mx+b中可选的x值的集合，New_x’s为需要函数TREND返回对应y值的新x值，Const为逻辑值指明是否强制常数项b为0。

### **TRIMMEAN**

**用途：**返回数据集的内部平均值。TRIMMEAN函数先从数据集的头部和尾部除去一定百分比的数据点，然后再求平均值。当希望在分析中剔除一部分数据的计算时，可以使用此函数。

**语法：**TRIMMEAN(array，percent)

**参数：**Array为需要进行筛选并求平均值的数组或数据区域，Percent为计算时所要除去的数据点的比例。如果 percent=0.2，则在20个数据中除去4个，即头部除去2个尾部除去2个。如果percent=0.1，30个数据点的10%等于3个数据点。函数TRIMMEAN将对称地在数据集的头部和尾部各除去一个数据。

**实例：**如果A1=78、A2=45、A3=90、A4=12、A5=85，则公式“=TRIMMEAN(A1:A5，0.1)”返回62。

### **TTEST**

**用途：**返回与学生氏-t检验相关的概率。它可以判断两个样本是否来自两个具有相同均值的总体。

**语法：**TTEST(array1，array2，tails，type)

**参数：**Array1是第一个数据集，Array2是第二个数据集，Tails指明分布曲线的尾数。如果 tails=1，TTEST函数使用单尾分布。如果tails=2，TTEST函数使用双尾分布。Type为t检验的类型。如果type等于(1、2、 3)检验方法(成对、等方差双样本检验、异方差双样本检验)

**实例：**公式“=TTEST({3，4，5，8，9，1，2，4，5}，{6，19，3，2，14，4，5，17，1}，2，1)”返回0.196016。

### **VAR**

**用途：**估算样本方差。

**语法：**VAR(number1，number2，...)

**参数：**Number1，number2，...对应于与总体样本的1到30个参数。

**实例：**假设抽取某次考试中的5个分数，并将其作为随机样本，用VAR函数估算成绩方差，样本值为A1=78、A2=45、A3=90、A4=12、A5=85，则公式“=VAR(A1:A5)”返回1089.5。

### **VARA**

**用途：**用来估算给定样本的方差。它与VAR函数的区别在于文本和逻辑值(TRUE和FALSE)也将参与计算。

**语法：**VARA(value1，value2，...)

**参数：**value1，value2，...作为总体的一个样本的1到30个参数。

**实例：**假设抽取某次考试中的5个分数，并将其作为随机样本，用VAR函数估算成绩方差，样本值为A1=78、A2=45、A3=90、A4=12、A5=85，则公式“=VARA(A1:A5，TRUE)”返回1491.766667。

### **VARP**

**用途：**计算样本总体的方差。

**语法：**VARP(number1，number2，...)

**参数：**Number1，number2，...为对应于样本总体的1到30个参数。其中的逻辑值(TRUE和FALSE)和文本将被忽略。

**实例：**如果某次补考只有5名学生参加，成绩为A1=88、A2=55、A3=90、A4=72、A5=85，用VARP函数估算成绩方差，则公式“=VARP(A1:A5)”返回214.5。

### **VARPA**

**用途：**计算样本总体的方差。它与VARP函数的区别在于文本和逻辑值(TRUE和FALSE)也将参与计算。

**语法：**VARPA(value1，value2，...)

**参数：**value1，value2，...作为样本总体的1到30个参数。

**实例：**如果某次补考只有5名学生参加，成绩为A1=88、A2=55、A3=90、A4=72、A5=85，用VARPA函数估算成绩方差，则公式“=VARPA(A1:A5)”返回214.5。

### **WEIBULL**

**用途：**返回韦伯分布。使用此函数可以进行可靠性分析，如设备的平均无故障时间。

**语法：**WEIBULL(x，alpha，beta，cumulative)

**参数：**X为用来计算函数值的数值，Alpha分布参数，Beta分布参数，Cumulative指明函数的形式。

**实例：**公式“=WEIBULL(98，21，100，TRUE)”返回0.480171231，=WEIBULL(58，11，67，FALSE)返回0.031622583。

### **ZTEST**

**用途：**返回z检验的双尾P值。Z检验根据数据集或数组生成x的标准得分，并返回正态分布的双尾概率。可以使用此函数返回从某总体中抽取特定观测值的似然估计。

**语法：**ZTEST(array，x，sigma)

**参数：**Array为用来检验x的数组或数据区域。X为被检验的值。Sigma为总体(已知)标准偏差，如果省略，则使用样本标准偏差。

**实例：**公式“=ZTEST({3，6，7，8，6，5，4，2，1，9}，4)”返回0.090574。

## 文本和数据函数

### CONCATENATE

- 用途：将多个文本字符串合并成一个。

- 语句：CONCATENATE(test1, [test2],…)

- 参数：需要合并的单个字符串

- 示例：当有的列数据是变化的，有的列不变可以这样合并

### EXACT 

- 用途：测试两个字符串是否完全相同。 如果它们完全相同， 则返回 TRUE;否则返回 FALSE。 EXACT函数能区分大小写，但忽略格式上的差异。
-  语法： EXACT(text1 ，text2) 。 
- 参数： Text1 是待比较的第一个字符串， Text2 是待比较的第二个字符串。 
- 实例：如果 A1=物理、A2=化学 A3=物理，则公式“=EXACT(A1，A2)”返回 FALSE，=EXACT(A1， A3)返回 FALSE，=EXACT("word"，"word") 返回 TRUE。

### FIND 

- 用途： FIND用于查找其他文本串 (within_text) 内的文本串 (find_text) ，并从 within_text 的首字符开始返回 find_text 的起始位置编号。此函数适用于双字节字符，它 区分大小写但不允许使用通配符。

- 语法： FIND(find_text ，within_text ，start_num) ， 
- 参数： Find_text 是待查找的目标文本 ;Within_text 是包含待查找文本的源文 本;Start_num 指定从其开始进行查找的字符，即 within_text 中编号为 1 的字符。如果忽 略 start_num ，则假设其为 1。 
- 实例： 如果 A1=软件报，则公式“ =FIND(" 软件"，A1，1)”返回 1。

### LEFT 

- 用途： 根据指定的字符数返回文本串中的第一个或前几个字符。 
- 语法： LEFT(text ，num_chars) 。 
- 参数： Text 是包含要提取字符的文本串 ;Num_chars 指定函数要提取的字符数，它必须 大于或等于 0。 
- 实例： 如果 A1=电脑爱好者，则 LEFT(A1，2) 返回“电脑”。

### LEN

- 用途： LEN返回文本串的字符数。
- 语法： LEN(text) 或 LENB(text) 。 
- 参数： Text 待要查找其长度的文本。
- 实例： 如果 A1=电脑爱好者，则公式“ =LEN(A1)”返回 5。

### LOWER 

- 用途： 将一个文字串中的所有大写字母转换为小写字母。
- 语法： LOWER(text)。 语法： Text 是包含待转换字母的文字串。 
- 实例： 如果 A1=Excel ，则公式“ =LOWER(A1)”返回 excel 。

### MID

- 用途： MID返回文本串中从指定位置开始的特定数目的字符，该数目由用户指定。 MIDB 返回文本串中从指定位置开始的特定数目的字符，该数目由用户指定。 

### MIDB

- 用途：函数可以用于 双字节字符。 
- 语法： MID(text ，start_num ，num_chars) 或 MIDB(text ，start_num ，num_bytes) 。 
- 参数：Text 是包含要提取字符的文本串。 Start_num 是文本中要提取的第一个字符的位 置，文本中第一个字符的 start_num 为 1，以此类推 ;Num_chars 指定希望 MID从文本中返回 字符的个数 ;Num_bytes 指定希望 MIDB从文本中按字节返回字符的个数。 
- 实例： 如果 a1=电子计算机，则公式“ =MID(A1，3，2) ”返回“计算”， =MIDB(A1，3，
  2)返回“子”。

### REPLACE 

- 用途： REPLACE使用其他文本串并根据所指定的字符数替换另一文本串中的部分文本。 
- 语法： REPLACE(old_text ，start_num ，num_chars，new_text) 
- 参数： Old_text 是要替换其部分字符的文本 ;Start_num 是要用 new_text 替换的 old_text 中字符的位置 ;Num_chars 是希望 REPLACE使用 new_text 替换 old_text 中字符的 个数 ;Num_bytes 是希望 REPLACE使用 new_text 替换 old_text 的字节数 ;New_text 是要用于 替换 old_text 中字符的文本。
- 实例： 如果 A1=学习的革命、 A2=电脑，则公式“ =REPLACE(A1 ，3，3，A2)”返回“学 习电脑”。

### RIGHT 

- 用途： RIGHT根据所指定的字符数返回文本串中最后一个或多个字符。
-  语法： RIGHT(text ，num_chars) 。 
- 参数： Text 是包含要提取字符的文本串 ;Num_chars 指定希望 RIGHT提取的字符数，它 必须大于或等于 0。如果 num_chars 大于文本长度，则 RIGHT返回所有文本。如果忽略 num_chars，则假定其为 1。 
- 实例： 如果 A1=学习的革命，则公式“ =RIGHT(A1，2) ”返回“革命”， =RIGHTB(A1， 2)返回“命”。

### SEARCH 

- 用途： 返回从 start_num 开始首次找到特定字符或文本串的位置编号。 SEARCH以字符 数为单位。 
- 语法： SEARCH(find_text ，within_text ，start_num) 。
- 参数： Find_text 是要查找的文本，可以使用通配符，包括问号“ ?”和星号“ *”。其 中问号可匹配任意的单个字符， 星号可匹配任意的连续字符。 如果要查找实际的问号或星号， 应当在该字符前键入波浪线 “~”。Within_text 是要在其中查找 find_text 的文本。Start_num 是 within_text 中开始查找的字符的编号。如果忽略 start_num ，则假定其为 1。 
- 实例： 如果 A1=学习的革命，则公式“ =SEARCH("的" ，A1)”返回 3，=SEARCHB("的"， A1)返回 5。

### SUBSTITUTE 

- 用途： 在文字串中用 new_text 替代 old_text 。如果需要在一个文字串中替换指定的文 本，可以使用函数 SUBSTITUTE;如果需要在某一文字串中替换指定位置处的任意文本，就应 当使用函数 REPLACE 。 
- 语法： SUBSTITUTE(text ，old_text ，new_text ，instance_num) 。 
- 参数：Text 是需要替换其中字符的文本， 或是含有文本的单元格引用 ;Old_text 是需要 替换的旧文本 ;New_text 用于替换 old_text 的文本 ;Instance_num 为一数值，用来指定以 new_text 替换第几次出现的 old_text; 如果指定了 instance_num ，则只有满足要求的 old_text 被替换 ; 否则将用 new_text 替换 Text 中出现的所有 old_text 。 
- 实例： 如果 A1=学习的革命、 A2=电脑，则公式“ =SUBSTITUTE(A1，" 的革命 " ，A2，1) ”
  返回“学习电脑”。

### TEXT 

- 用途： 将数值转换为按指定数字格式表示的文本。 
- 语法： TEXT(value ，format_text) 。 
- 参数： value 是数值、计算结果是数值的公式、或对数值单元格的引用 ;format_text 是所要选用的文本型数字格式，即“单元格格式”对话框“数字”选项卡的“分类”列表框 中显示的格式，它不能包含星号“ *”。

**注意：** 使用“单元格格式”对话框的“数字”选项卡设置单元格格式，只会改变单元格 的格式而不会影响其中的数值。使用函数 TEXT可以将数值转换为带格式的文本，而其结果 将不再作为数字参与计算。 实例： 如果 A1=2986.638 ，则公式“ =TEXT(A5，"# ，##0.00") ”返回 2，986.64 。

### TRIM 

- 用途：除了单词之间的单个空格外， 清除文本中的所有的空格。 如果从其他应用程序中 获得了带有不规则空格的文本，可以使用 TRIM函数清除这些空格。 
- 语法： TRIM(text) 。 
- 参数： Text 是需要清除其中空格的文本。 
- 实例： 如果 A1=FirstQuarterEarnings ，则公式“ =TRIM(A1)”返回 “FirstQuarterEarnings ”。

### UPPER 

- 用途： 将文本转换成大写形式。 
- 语法： UPPER(text) 。 
- 参数： Text 为需要转换成大写形式的文本，它可以是引用或文字串。 
- 实例： 公式“ =UPPER("apple") ”返回 APPLE。

### value 

- 用途： 将表示数字的文字串转换成数字。 
- 语法： value(text) 。
- 参数：Text 为带引号的文本， 或对需要进行文本转换的单元格的引用。 它可以是 Excel 可以识别的任意常数、日期或时间格式。如果 Text 不属于上述格式，则 value 函数返回错 误值 #value! 。

 **注意：**通常不需要在公式中使用 value 函数，Excel 可以在需要时自动进行转换。 value 函数主要用于与其他电子表格程序兼容。 实例：公式“=value(" ￥1，000") ”返回 1000;=value("16:48:00")-value("12:00:00") 返回 0.2 ，该序列数等于 4 小时 48 分钟。

## 日期函数

### DATE 

- 用途： 返回代表特定日期的序列号。 
- 语法： DATE(year，month，day) 
- 参数： year 为一到四位，根据使用的日期系统解释该参数。默认情况下， Excel for Windows 使用 1900 日期系统，而 Excel for Macintosh 使用 1904 日期系统。 Month 代表每 年中月份的数字。如果所输入的月份大于 12，将从指定年份的一月份执行加法运算。 Day 代表在该月份中第几天的数字。如果 day 大于该月份的最大天数时，将从指定月份的第一 天开始往上累加。 注意 :Excel 按顺序的序列号保存日期，这样就可以对其进行计算。如果工作簿使用的 是 1900 日期系统，则 Excel 会将 1900 年 1 月 1日保存为序列号 1。同理，会将 1998 年 1 月 1 日保存为序列号 35796，因为该日期距离 1900 年 1 月 1 日为 35795 天。
- 实例：如果采用 1900 日期系统 (Excel 默认 )，则公式“=DATE(2001，1，1) ”返回 36892。

### DATEVALUE 

- 用途：返回 date_text 所表示的日期的序列号。 该函数的主要用途是将文字表示的日期 转换成一个序列号。 

- 语法： DATEVALUE(date_text)

- 参数： Date_text 是用 Excel 日期格式表示日期的文本。在使用 1900 日期系统中， date_text 必须是 1900 年 1 月 1 日到 9999 年 12 月 31 日之间的一个日期 ; 而在 1904 日期系 统中， date_text 必须是 1904 年 1 月 1 日到 9999 年 12 月 31 日之间的一个日期。如果 date_text 超出上述范围，则函数 DATEVALUE返回错误值 #value! 。 如果省略参数 date_text 中的年代，则函数 DATEVALUE使用电脑系统内部时钟的当前年 代，且 date_text 中的时间信息将被忽略。 

- 实例： 公式“ =DATEVALUE("2001/3/5") ”返回 36955，DATEVaLUE("2-26") 返回 36948。

### DAY

- 用途： 返回用序列号 ( 整数 1 到 31) 表示的某日期的天数，用整数 1 到 31 表示。 
- 语法： DAY(serial_number)
-  参数： Serial_number 是要查找的天数日期，它有多种输入方式 : 带引号的文本串 ( 如 "1998/01/30") 、序列号 ( 如 1900 日期系统的 35825 表示 的 1998 年 1 月 30 日) ，以及其他 公式或函数的结果 (如 DATEVaLUE("1998/1/30")) 。
- 实例： 公式“ =DAY("2001/1/27") ”返回 27，=DAY(35825)返回 30， =DAY(DATEVaLUE("2001/1/25")) 返回 25。

### MONTH 

- 用途： 返回以序列号表示的日期中的月份，它是介于 1( 一月 ) 和 12( 十二月 )之间的整 数。 
- 语法： MONTH(serial_number) 
- 参数： Serial_number 表示一个日期值，其中包含着要查找的月份。日期有多种输入方 式: 带引号的文本串 (如"1998/01/30") 、序列号 (如表示 1998 年 1 月 30 日的 35825) 或其他 公式或函数的结果 (如 DATEVaLUE("1998/1/30")) 等。 
- 实例： 公式“ =MONTH("2001/02/24") ”返回 2，=MONTH(35825)返回 1， =MONTH(DATEVaLUE("2000/6/30")) 返回 6。

### TODAY

- 用途： 返回系统当前日期的序列号。 
- 语法： WEEKDAY(serial_number，return_type) 
- 参数： 无 语法： TODAY() 实例： 公式“ =TODAY()”返回 2001-8-28( 执行公式时的系统时间 ) 。
  WEEKDAY 用途： 返回某日期的星期数。在默认情况下，它的值为 1( 星期天 )到 7( 星期六 )之间的 一个整数。 
- 参数： 
  - Serial_number 是要返回日期数的日期，它有多种输入方式 : 带引号的文本串 ( 如 "2001/02/26") 、序列号 ( 如 35825 表示 1998 年 1 月 30 日) 或其他公式或函数的结果 ( 如 DATEVaLUE("2000/1/30")) 。
  - Return_type 为确定返回值类型的数字， 数字 1 或省略则 1 至 7 代表星期天到数星期六， 数字 2 则 1 至 7 代表星期一到星期天， 数字 3 则 0 至 6 代表星期一 到星期天。 
- 实例： 公式“ =WEEKDAY("2001/8/28" ，2) ”返回 2( 星期二 )，=WEEKDAY("2003/02/23" ， 3)返回 6(星期日 )。

### YEAR 

- 用途： 返回某日期的年份。其结果为 1900 到 9999 之间的一个整数。 
- 语法： YEAR(serial_number) 
- 参数： 
  - Serial_number 是一个日期值，其中包含要查找的年份。日期有多种输入方式 : 带引号的文本串 ( 例如 "1998/01/30") 、序列号 ( 例如，如果使用 1900 日期系统则 35825 表 示 1998 年 1 月 30 日) 或其他公式或函数的结果 (例如 DATEVALUE("1998/1/30")) 。 
- 实例： 公式“ =YEAR("2000/8/6") 返回 2000”，=YEAR("2003/05/01") 返回 2003， =YEAR(35825)返回 1998。